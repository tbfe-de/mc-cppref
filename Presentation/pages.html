<!DOCTYPE html>
<html>
  <head>
    <title>C++ Refresh</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [for MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [for MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies approximately 2/3 of the page width. So only add
  little information, preferably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [for MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
template: blank
name: frontmatter

.title[
	C++ Refresh
]

.subtitle[
	An Refresher's Overview on C++ Based On 
	Classic and Modern Language Standards
]
.author.pull-left[
	Durchführung:  
	Dipl.-Ing. Martin Weitzel  
	Technische Beratung für EDV  
	http://tbfe.de  
]
.client.pull-right[
	Im Auftrag von:  
	MicroConsult  
	Training & Consulting GmbH  
	http://www.microconsult.com
]

---
template: plain
class: agenda
name: agenda
header: ## Agenda

This agenda and the following pages show a proposed path through the topics
selected for the next two days.

-------------------------------------------------------------------------------

* [The C/C++ Preprocessor			](#c_cpp_preprocessor)
* [C++-Basics – General Extensions to C		](#cpp_extensions)
* [Object-Oriented Programming			](#oop_intro)
* [Introduction to Exceptions			](#exception_intro)
* [Dynamic Memory Allocation 			](#dynamic_memory)
* [Strings and Streams				](#stdlib_strings_streams)
* [Introduction to Templates			](#template_intro)
* [STL (Containers and Algorithms)		](#stdlib_stl)
* [Generalized Callables			](#generalized_callables)
* [Optional: More of Modern C++			](moderncpp.html)
* [Optional: Concurrency Basics			](concurrency.html)
* [Appendices and Info-Graphics			](#appendices)

-------------------------------------------------------------------------------

Variations and extensions can be agreed any time.

---
template: plain
name: interrupt_me
header: ### Interrupts Enabled

Some parts of this training are meant to be given really

.center.large[*"Hands On"*]

i.e. your hands on the keyboard, while following the explanations … feel free
to ask questions anytime and push coverage of C++ features – including the live
examples – into the direction that most satisfy your needs.

.N.center[
Nothing is absolutely "fixed" here – this course is given by a human, not a
book that keeps silent if you do not understand something.
]

???

#### Proposed Explorations:

* Write a "hello, world" program:

  * In Visual Studio be sure to use "C++ Console Project".

  * Chose "Hello World" for the start

* Explain different ways to start it so that the final output is visible.

  * In Visual Studio hint to "Start Without Debugging" (CTRL-F5).

  * Or place instruction to wait for a key at end (`cin.ignore(1)`).

* Put a second source file program in the same project.

  * Show how to compile only one.

  * Alternatively (especially for Eclipse Users) show how to clone a whole
    project.

---
template: plain
name: online_vs_offline
header: ## Online vs. Offline Resources

You may already have received this presentation printed on paper. This is
because most people find it still easier to make annotations on paper.

.N[
If you only have an electronic version you may print it out yourself.
]

Note that any version of this document – printed or electronic and *including*
all copies you make yourself – are distributed under a

.center[**Creative Commons BY-SA License**]

Basically this means you need to

* keep the original author's name and organization in the page footer
* license any derived work you publish in the same way.

.I[
For more details please see here:  
https://creativecommons.org/licenses/by-sa/3.0/  
Weitere Details finden Sie hier:  
https://creativecommons.org/licenses/by-sa/3.0/de/
]

---
template: plain
name: online_vs_offline
header: ### Online Version of this Presentation

You may download an online version of the presentation from the internet:

.N.center[
Go to
https://www.github.com/tbfe-de/mc-cppref  
from their either chose *Download Zip-File* (and unpack) it  
or if you know how to use `git clone` the whole archive.
]

Make sure the following is finally available on your local system:._[]

* `Presentation/pages.html`
* `Presentation/remark.min.js`
* `Presentation/CSS/styling.css`

This is the minimum necessary to view the presentation by opening
`pages.html` in any recent browser, with JavaScript enabled.

.F[:
The whole presentation consists of more files, most importantly in the
sub-directories `Infographics` and `PNG`. The former are large graphics on used
for extended (but mostly optional) explanations. The latter supplies some Icons
and Logos, serving rather cosmetic aspects.
]

---
template: plain
name: online_vs_offline
header: ### External Online Resources

There are many resources in the internet with in-depth coverage of most any
C++ feature, at basic, intermediate, and advanced levels.

.N[
This document does not duplicate information readily available elsewhere but
rather provides links to it.
]

If you view the presentation on a computer anyway it is suggested to prefer the
HTML-version over the PDF-version, as you may

* navigate to related information by simply clicking the links and

* also view the presenter's notes and even choose to use them for your own
  annotations.

The PDF-version has the (small) advantage that it is a single file that can be
used "stand-alone".._[]

.F[:
The PDF version is most easily created from Google Chrome or some chrome-based
browser with *Export to PDF* or *Print to PDF* or, if the final goal are
print-outs anyway, by direct printing.
]

---
template: plain
name: online_compilation
header: #### Online C++ References

For any non-trivial technical product, at some point you need to look-up
detailed information, as e.g. it is provided in reference manuals.

.I[
For C++ a good collections of reference material are here:  
http://en.cppreference.com/w/  
http://www.cplusplus.com
]

Both now on many of their pages have example sections with has code that can
be

* compiled as is, or
* modified and compiled again.

The former uses [Coliru] (= **Co**mpile, **li**nk, and **ru**n) the latter
[C++ shell] as online compile service (see next page).

[Coliru]: http://coliru.stacked-crooked.com
[C++ shell]: http://cpp.sh

.F[:
Besides the coverage of the standard library cppreference.com also has sections
on language features. As these take a rather formal and dry approach, they are
– of course – precise but often use phrasing that is not easy to comprehend,
and is also rich in details which are unimportant for an initial understanding.
]

---
template: plain
name: online_compilation
header: #### Online C++ Compilers

In recent years free *Online Compile Services* became available.._[]

.N.center[
These are basically internet sites with web front-ends to one or more
programming languages (compiled or interpreted).
]

C++ Online Compilers are great tools and while details vary many allow

* not only to try small programs (e.g. as "proof of concept")
  * without installing a compiler and library
  * let alone a whole development environment,

<!-- -->

* but also to compare the behaviour of several compiler versions or brands
  easily, and

<!-- -->

* to save such code examples returning a *permalink* which you then may
  send to others to discuss the code, be it
  * privately with colleagues and friends, or
  * in public on platforms like stack-overflow.

.F[:
While some have been switched of again
[Coliru](http://coliru.stacked-crooked.com)
– which the author of this uses a lot – has been there since many years and
still is.
[Wandbox](http://wandbox.org)
is a more recent one with a little more embellished UI. With both you may
choose between *g++* and *clang++* and both include a recent version of the
[Boost Library](http://www.boost.org).
]

???

##### Proposed Explorations:

* Show some online compilers like:

  * Use Coliru to compile a "hello, world" example.

* Also try other online compilers, like

    * http://wandbox.org

* What its the purpose of this special online compiler?

  * http://gcc.godbolt.org/

---
template: plain
name: c_cpp_preprocessor
header: ## The C/C++ Preprocessor

The C preprocessor was introduced long ago to automate several kinds of
systematic editing:._[]

* write common parts of several files only once (`#include`)

* conditionally compile portions of the source code (`#if`, `#ifdef`, …)

* repeatedly insert (nearly) identical code sequences to avoid function call
  overhead for tiny subroutines (`#define`)

In C++ many "classic" use cases of the preprocessor were superseded by builtin
language features, though at times it still comes in handy.

.N.center[
But also keep in mind:  
The C Preprocessor doesn't know about C.  
🙂
]

.F[:
Also, in the early years of C, on the PDP-11, separating some features from the
compiler proper was necessary as the executable program file was limited to
64+64 kB (Code+Data).
]

---
template: plain
name: preprocessor_uses
header: ### Preprocessor Use Cases

The set of still valid use cases is small, but not empty:

.pull-left[

* Centralising common code via [Header Files](#header_files).

* Using [Include Guards](#include_guards) to avoid header files being processed
  more than once.

* [Special Usage Macros](#special_usage_macros)

]
.pull-right[
]
.pull-right[
An example where a macro is indispensable is this, where `assert` first
evaluates its argument as C++ expression …
```
void f(const char *cp) {
	assert(cp != nullptr);
	…
}
```
]

… but also requires it as character string for output, if the assertion
fails.

* The key mechanism here is only provided for macro arguments (as part of macro
  replacement text) and called *Stringizing*, requested with `#` in front of a
  macro argument name.

* Similarly, `##` is the so-called *Token Pasting* operator._[], exclusively
  available in macro replacement text too.

.F[:
A use case for token pasting is provided in the exploration section for
[Configurable Exceptions](#configurable_exceptions).
]

---
template: plain
name: header_files
header: #### Header Files

Header files can be supplied by the system or be specific for a project:

* System header files are looked-up in a set of predefined locations.._[]

* Project specific header files are *first* looked up in locations associated
  with the project, *then* in the locations of the system header files.

Only regular slashes as path separators in include file names are portable
(assuming the directory structure is matched), **backslashes are not**.

.pull-left[
Example for system header files:
```
#include <cassert>
#include <iostream>
#include <string>
…
```
]
.pull-right[
Example for project specific header files:
```
#include "mylib/utilities.h"
#include "point.h"
…
```
]

.F[:
C++ implementations have the freedom instead of reading a file that exists in
the file system to enable a predefined set of features within the compiler.
Furthermore in C++ any system header **may** include other system headers.
This may cause (mild) portability issues when switching compilers or even a
complete development environment.
]


---
template: plain
name: include_guards
header: #### Include-Guards

Since the early times C, due to the

.N.center[
ODR – One Definition Rule
]

it is a well-known "best practice to

* wrap all the actual content of a header file in a big conditional
  compilation,

* so that duplicating an `#include` for it does no harm.._[]

```
#ifndef MY_HEADER  // <--- begin of header file content
#define MY_HEADER
     // ^^^^^^^^^-- anything valid as unique macro name
     // …
     // … actual header content
     // …
#endif // <--------------- end of header file content
```

.F[:
It is common practice to include one header from another header if the second
depends on the first, though be aware of the potential problems caused by
cycles in the dependency graph.
]

---
template: plain
name: 
header: #### Special Usage Macros

The following macro is often useful for creating output._[] in tiny programs
used for testing and demonstrations,

* not only **showing the value of some expression**,
* but also that very expression as text, after
* the name of the compiled file, and
* the line number from where the macro was called.

```
#define PX(expr)\
    (void)(std::cout << __FILE__ << '[' << __LINE__ << ']'\
                     << "\t" #expr " --> " << (expr) << std::endl)
```

.F[:
Same as useful is a macro written for the purpose of showing a type:

```
  #define PT(...)\
    (void)(std::cout << __FILE__ << '[' << __LINE__ << ']'\
                     << "\t" #__VA_ARGS__ " --> "\
                     << boost::typeindex::type_id_with_cvr<__VA_ARGS__>()\
                     << std::endl)
```
]

---
template: plain
name: cpp_extensions
header: ## How C++ Extends C

* [Arithmetic Types	](#arithmetic_types)
* [Const-Qualifiers	](#const_qualifiers)
* [Pointers and Arrays	](#pointers_and_arrays)
* [References		](#references)
* [Default Arguments	](#default_args)
* [Function Overloading	](#function_ovld)
* [Operator Overloading	](#operator_ovld)

It should be understood that "under the hood", C and C++ are both mapped to the
hardware in the same, basic way.
.N.center[
So, from the low-level view, they use the same [Execution Model](#execution_model).
]

---
template: plain
name: arithmetic_types
header: ### Arithmetic Types

C++ has all the arithmetic types that C has, including a special type for
binary logic (`bool` with value `true` and `false`).

Conversions between arithmetic types take place automatically:._[]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
int i = -12;      // always OK
unsigned u = i;   // OK (maybe compile time warning)
short t{32768};   // new C++11 style initialization,
                  // overflow error at compile time if
                  // short is 16 bit two-s complement
char c = t+122;   // OK (maybe compile time warning)
if (c) …          // every value not 0 is taken as true
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


C++11 allows to use `auto` as typename; the type of the variable will be the
type of the initializing expression (without `const` and *reference*):

```
auto x = 3.1415;  // x will have type double
auto y = 1.4142f; // y will have type float
```

.F[:
There may be a warning if loss of information is possible. This is typically
based on the types involved, not on some analysis of actual values (which may
or may not be fully determinable at compile time).
]

???

##### Proposed Explorations:

* Compile the examples on this page without modifications, except the last one
  (which is only a partial if-statement – it will be covered later).

* After each variable *`v`* declared, in the same line add:  
  `PX(`*`v`*`); PT(decltype(`*`v`*`);`

* Place a `//`-comment in front of any line causing a compile error.

* Does the output meet your expectations?

* Change the line causing a compile error to classic (C/C++98) syntax.

* Add the following line (note the curly braces!):
  `if (auto a = i) { PX(a); PT(decltype(a)); }`

* Explain the output.

* Demonstrate `x` and `y` have the type claimed in the comments.

* How could both changed to type `long float` while **keeping** their type
  `auto`?

ADVANCED:

* Copy the last line (with the `if`-statement three times and replace the
  the variable `i` with `u`, `t`, and `c`.

* Again explain the output.

* How far does the scope of `a` extend (obviously)?

* Set an initial for `i` and `t` so that no output is generated from the
  `if`-statements containing them.

* Does this value always to be zero?

* Find a value for `t` so that no output is generated from the `if`-statement
  containing `c`.

---
template: plain
name: uniform_initialization
header: #### Brace Initialization

C++11 also extended the initialization syntax

* to allow

  * initial values be written in a pair of curly braces anywhere._[] and
  * (only in this case) omitting the equals sign between the variable name
    and the opening brace.

* provided a whole new (template) type `std::initializer_list<T>`

* written as comma-separated list of identical or compatible types
  * enclosed in a pair of curly braces.

.W[
While the original intent was to "simplify" the initialisation syntax, there
were some unexpected stumbling-stones in combination with `auto`.
]


.F[:
Traditionally C and C++ supported this syntax only for structures and native
arrays.
]

???

##### Proposed Explorations:

* Rewrite the following initialisations using the braces:
```
int x = 42;
double y = 0;
bool b = false;
struct point {
    double x, y;
};
point zz = {0.0, 0.0};
const point p1 = {3.5, 17};
point p2 = p1;
```

* Explain the warnings (if any) and compile errors:
```
int x = 4.2;
int y {4.2};
float z = x/y;
const char c = '€';
```

ADVANCED

* Try to determine what values `v1` to `v8 will initially hold:
```
std::vector<int> v1 = { 2, 3, 5, 7, 11 };
std::vector<int> v2{ 2, 3, 5, 7, 11 };
std::vector<int> v3({ 2, 3, 5, 7, 11 });
std::vector<int> v4({ 2, 3, 5, 7, 11 });
const std::vector<int> v5 = { 2, 3, 5, 7, 11 };
const std::vector<int> v6{ 2, 3, 5, 7, 11 };
std::vector<int> v7(3);
std::vector<int> v8{3};
std::vector<int> v9{};
```

* Why does the following **not** define an empty vector?
```
std::vector<int> v0();
```

---
template: plain
header: #### Enforcing Conversions / Suppressing Warnings

Conversions need sometimes to be enforced with cast operations:._[]
```
int x = 9;
int y = 5;
double d = static_cast<double>(x) / static_cast<double>(y);
        // instead of C-style cast: (double)x / (double)y
```
Also, cast operations are sometimes used with the intent to suppress a warning:
```
short s = static_cast<short>(d);
```
.N[
Which warning is issued under what circumstance and how it can be suppressed is
always compiler specific.
]

.F[:
C-style casts are still part of the C++ language but a deprecated language
feature because they are hard to spot and the intention is not as much part of
the syntax as with the C++-style cast, for which more examples will be shown
later.
]

???

##### Proposed Explorations:

* Demonstrate different applications of `static_cast`.

  * With GCC conversion warnings need first be enabled with `-Wconversion`.

  * Then eliminate warning via explicit `static_cast`.

  * With Visual Studio try to enable warnings with /Wall

ADVANCED

* Change the variable declaration of `d` to `auto` and systematically try the
  following initialisations:

  * `                         x  / y;`
  * `                         x  / static_cast<float>(y);`
  * `      static_cast<float>(x) / static_cast<float>(y);`
  * `     static_cast<double>(x) / static_cast<float>(y);`
  * `static_cast<long double>(x) / static_cast<float>(y);`
  * `                         x  / static_cast<double>(y);`
  * `      static_cast<float>(x) / static_cast<double>(y);`
  * `     static_cast<double>(x) / static_cast<double>(y);`
  * `static_cast<long double>(x) / static_cast<double>(y);`
  * `                         x  / static_cast<long double>(y);`
  * `      static_cast<float>(x) / static_cast<long double>(y);`
  * `     static_cast<double>(x) / static_cast<long double>(y);`
  * `static_cast<long double>(x) / static_cast<long double>(y);`

* For each predict the type and (approximate or exact) value of `d`.

---
template: plain
name: const_qualifiers
header: ### Qualifiers Implying Immutability

There are two qualifiers._[] making a variable" immutable:

* `const` is applicable to variables only:

  * the compiler will not generate code that modifies the initial value

  * the linker may or may not put the variable in read-only memory

* `constexpr` is applicable to variables and functions:

  * for a variable it guarantees the initial value can be calculated at
    compile time

  * for functions it does the calculations at compile time, if possible

.F[:
`const` was originally introduced with C++ but also became part of the C89
standard – hence today, 25 years later, it may well be reclaimed as a C++
addition but few people still know today. Nevertheless it seems even today C++
programs make more use of this feature than C programs. `constexpr` was
introduced with C++11.
]

---
template: plain
header: #### `const` Is To Ensure Immuability

A variable may optionally be qualified with `const`:._[]
.pull-left[
Brace Initialization:
```
const int x{17};
float const PI{2*std::acos(0.0)};
```
]
.pull-right[
Classic Initialization:
```
const int x = 17;
double const PI = 2*std::acos(0.0);
```
]

* There must be an initialisation (except when `extern`)

* subsequent attempts to modify the variable

  * result at least in a compile time error

  * may also cause a run time error

.N[
As the examples show, the `const` qualifier may be written to the left or to
the right of the type to which it applies.
]

.F[:
The `const` qualifier was originally introduced with C++ but also became part
of the C89 standard – hence today, 25 years later, it may well be reclaimed as
a C++ addition but few people still know. Nevertheless it seems even today C++
programs make more use of this feature than C programs.
]

???

##### Proposed Explorations:

Demonstrate various effects of using `const`:

* Omitting initialisation.

* Attempt to modify.

---
template: plain
header: #### `constexpr` Is To Ensure Compile Time

Variables and Functions may optionally be qualified with `constexpr`:
.pull-left[
```
constexpr float PI{3.14159};
```
]
.pull-right[
```
constexpr float PI = 3.14159;
```
]

Qualifying a variable with `constexpr` requires the initial value can be
calculated at compile time.

.N[
This is not limited literal values, expressions and calling `constexpr`
qualified functions with `constexpr` arguments is also supported.
]

Note that the following may or may not work, depending on whether `std::acos`
is `constexpr`:._[]

```
constexpr float PI{std::acos(0.0f)};
```

.F[:
The inverse cosine function is defined in header `<cmath>`. The C++11 standard
does not require it is `constexpr` though it is with the GCC-Compiler (`g++`)
but not with the LLVM-Compiler (`clang++`).
]

???

##### Proposed Explorations:

Consider the following `constexpr` functions:

```
constexpr auto highbit(unsigned long long n) {
    unsigned result{0};
    for (; n; n >>= 1) ++result;
    return result;
}
constexpr auto maskof(unsigned long long n) {
	return n ? (1 << highbit(n)) - 1 : 0;
}
constexpr unsigned long long z{maskof(123)};
```

* Determine from a code analysis what the functions `highbit` and `maskof` do.

* Verify by adding an executable program like this:

```
#include <iostream>
#include <iomanip>
using namespace std;

int main() {
    for (auto i : { 1, 2, 3, 4, 5, 10, 20, 100, 200, 255,
                    256, 127, 63, 31, 15, 7, 3, 1, 0 }) {
        cout << "i = " << dec << setw(5) << i
             << "  highbit = " << dec << setw(2) << highbit(i)
             << "  maskof = 0x" << hex << maskof(i)
             << endl;
    }
}
```

---
template: plain
name: arrays_and_pointers
header: ### Arrays and Pointers

Arrays and pointers are (sometimes) confused because for function arguments
there are two different ways to express the same concept:

.pull-left[
```
void foo(short arr[]) {
    …
}
```
]

.pull-right[
```
void bar(short *p) {
    …
}
```
]

Both are essentially equal as – behind the scenes – the functions will be
called with the address of an `int` (arithmetic type).
.N[
The difference in information conveyed in the two cases is rather about intent:

* `foo` will (presumably) be called with the address of the first element of an
   array of `int`-s;
* `bar` will be called with the address of a (presumably) single `int` or maybe
   even a null pointer.
]

???

##### Proposed Explorations:

When called from a program like

```
int main() {
    short arr[10];
    short i;

    foo(arr);
    bar(&i);
}
```

* Print pointer (address) of `arr` and `p` in both, `foo` and `bar`.

  * Switch order of definition of `arr` and `i`.

  * Switch calls (address of variable to first and pointer to second).

  * Omit taking address (`&`) from variable

  * Add taking address to array.

ADVANCED

* Apply `sizeof`:

  * To the variables in the main program.

  * To the arguments of `foo` and `bar`.

---
template: plain
header: #### Indexing and Address Arithmetic

When used to define some data item, arrays and pointers are different:

.pull-left[
For an array storage space is set aside to store the requested number of items
of the given type:
```
double data[20];
char message[1024];
```
Individual items are typically accessed by giving their index:
```
… data[12] …
… message[i] …
```
Given a pointer points to an array cell …
```
dp = &data[0];
cptr = &message[i];
```
]

.pull-right[
For a pointer only memory space to hold an address is set aside:
```
double *dp;
char *cptr;
```
Assuming an appropriate initialisation items pointed to are accessed by
dereferencing:
```
… *dp …
… *cptr …
```
… also address arithmetic can make sense:
```
… ++dp …
… *(cptr-3) …
```
]

???

##### Possible Explorations

* Print addresses of arrays and content of pointer variables.

  * Use various combinations of taking address and indexing.

* Show the following is the same address:

  * `data` and `&data[0] and `&data`

  * `message` and `&message[0]` and `&message`

ADVANCED

* Show the different types of `data` and `&data`

  * using `PT` and `decltype`
  * **not** using `PT` and `decltype`

---
template: plain
header: #### Equivalence of Indexing and Address Arithmetic

There are two basic rules that make pointers and arrays equivalent when it
comes to indexing and address arithmetic:

* In almost any context._[] the pure name of an array decays to a pointer to
  the first array element, i.e. `data` and `&data[0]` are equivalent.

* All pointer arithmetic is scaled with the storage size of the underlying
  type, making

  * `ptr+i` equivalent to `&ptr[i]` and

  * `*(ptr+i)` equivalent to `ptr[i]`.

.N[
In C++ the need to use C low-level data types like arrays and pointers strongly
diminishes as the standard library offers more convenient abstractions like
[Container Classes](#stl_containers) and [Smart Pointers](#smart_pointers).
]

.F[:
Exceptions are when the name of an array is used with the `sizeof` of
`&`-operator: then it will keep its array type, so `sizeof data` is the size
the whole array occupies (in bytes) and `&data` is the address of the whole
array, which is – of course – the same as the address of its first element but
will use a different scaling for address arithmetic.
]

???

##### Possible Explorations

* Play with various combinations of indexing and taking address for array:

  * (plain) `data`
  * `data + 1`
  * `&data[1]`
  * `&data + 1`

* Do similar for pointers:

  * (plain) `ptr` (when initialized)
  * `ptr + 1`
  * `&ptr[1]`
  * `&ptr + 1`

---
template: plain
header: #### Arrays

Arrays belong to the C++ subset of language features assumed from C:

* the size must be fixed at compile time.
* unless an initialisation is supplied:

```
double data[200];
int primes_table[] = {
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29
};
```
In addition to the array data there is often some extra information stored (in
separate variables) up to which element an array is filled …
```
double *filled = &data[0]; // location of next free space
*filled++ = …; // idiomatic style to fill array with values
```
or how many entries exist in an initialised array:
```
const auto N = sizeof primes_table / sizeof primes_table[0];
```

???

##### Possible Explorations

* What is the difficulty to write an output function that prints an aray of
  integers of any size?

* How can it be overcome?

---
template: plain
header: #### Arrays (2)

The size information needs eventually be presented to functions that process
the content of same array, as the pure array name – when used as function
argument – decays to a pointer to the first array element:._[]
```
void print_primes(int table[], std::size_t count) {
    using namespace std;
    for (int i = 0; i < count; ++i) cout << table[i] << endl;
}
…
print_primes(primes_table, N);
```
Or:
```
double sum_data(double *from, double *to) {
    double s = 0; while (from < to) s += *from++; return s;
}
…
auto sum = sum_data(data, filled);
```

.F[:
The C++ Standard Library provides the classes `std::array` and `std::vector`
that may often be used as drop-in replacements for built-in arrays but bundle
size information with the data.
]

???

##### Possible Explorations (slightly advanced)

Something along the lines of a program like this:

```
#include <iostream>

int primes_table[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 };
const auto N = sizeof primes_table / sizeof primes_table[0];

void show_array1() {
    for (auto x  : primes_table)
        std::cout << x << ' ';
     std::cout << std::endl;
}

/*
void show_array2(int primes[]) {
    for (auto x  : primes)
        std::cout << x << ' ';
    std::cout << std::endl;
}
*/

void show_array3(int primes[], int size) {
    for (int i = 0; i < size; ++i)
        std::cout << primes[i] << ' ';
    std::cout << std::endl;
}

template<typename T>
void show_array4(const T& primes) {
    for (auto x  : primes)
        std::cout << x << ' ';
    std::cout << std::endl;
}

int main() {
    show_array1();
//  show_array2(primes_table);
    show_array3(primes_table, N);
    show_array4(primes_table);
}

```

---
template: plain
header: #### `const` Arrays

Arrays qualified with `const` must be initialised and cannot be modified:
```
const int primes_table[] = {
    2, 3, 5, 7, 11, 13, 17, 19, 23, 29
};
```
.N[
Initialised write protected arrays are good for pre-calculated tables of data
as it can be loaded into initialised storage from the program's executable
image.
]

As `const` in C++ silently implies internal linkage, to share such data between
translation units its declaration must also be qualified with `extern` in a
header file included by all interested parties:
```
extern const int primes_table[];
```
The initialisation from above then goes into **exactly one** translation unit.

.F[:
The rule *`const` implies internal linkage* allows to put the definition and
initialisation of `const` data into header files without multiple definitions
of the same symbol leading to linker errors.
]

???

##### Possible Explorations

Example showing the effects of internal linkage for `const`.

* Requires at the beginning use two translation units with explicit external
  declaration.

```
// file: primes_table.cpp
const int primes_table[] = { 2, 3, 5, 7, 11 };
void show_primes() {
    for (auto x : primes_table)
        std::cout << x << ' ';
    std::cout << std::endl;
}
```
```
// file: main.cpp
int main() {
    show_primes();
    for (auto x : primes_table)
        std::cout << x << ' ';
    std::cout << std::endl;
}

```

* Then put definition of primes_table into *both* files …

  * … with same initialization;
  * … with different initialisation.

* Finally include header file with the following content into both:

```
// file: primes_table.h
extern const int primes_table[];
```

---
template: plain
name: pointers
header: #### Pointers

Pointers belong to the C++ subset of language features assumed from C.

Differently typed pointers are generally incompatible with each other:
```
int i;   // a memory location to hold int-s
int *ip = &i; // a pointer to that location
float *fp = ip; // ERROR
```

.N[
If the above assignment to `fp` would pass, via `*fp` the memory location
holding an `int` could be accessed as if it were a `float`.._[]
]

This also defeats usage errors of multi-level pointers:
```
int **ipp = &ip;  // pointer to pointer
int x = 3 * *ipp; // single indirection still leaves pointer
                  // which cannot be multiplied by an int
```

.F[:
Write access could even extend beyond that and change unrelated variables, if
the type that determines memory space is smaller that the type the pointer
claims to point to.
]

???

##### Possible Explorations

* Show various errors when mixing differently typed pointers.

* Understand and explain the messages.

---
template: plain
header: #### Typed Pointers vs. Generic Pointers (`void *`)

There is a difference between C and C++ in compatibility of typed and generic
pointers in, which adds more type safety:

.pull-left[
In C type compatibility is both ways, from generic to typed and from typed to
generic pointers:
```
int *ip;
…
void *p = ip;  // C: OK
float *fp = p; // C: OK
```
]
.pull-right[
In C++ type compatibility is one-way – from generic to typed is an error:._[]
```
int *ip;
…
void *p = ip;  // C++: OK
float *fp = p; // C++: ERROR
```
]

When at a given point the true nature of a generic pointer is known, it may be
assigned back to the original typed pointer type using a cast:
```
int *ip2 = static_cast<int*>(p);
```

.F[:
Despite slightly improved type safety in C++ generic pointers cut a big hole in
compile-time type checking, as anyway at some point there needs to be a cast
which requires that type information is somehow embedded in the program logic.
If the set of possible types is bounded at design time, class hierarchies are
usually a superior alternative while for type-generic coding – e.g. in basic
libraries – parametrizing types via templates provides stringent type-checking
at compile-time.
]

???

##### Possible Explorations

* Show errors when mixing generic and typed pointers.

* Demonstrate `static_cast` is sufficient for going from `void*` to `T*`.

* Demonstrate `reinterpret_cast` 

---
template: plain
header: #### Arbitrary Type Conversions

With the possibility of arbitrary type conversions it is easy to introduce type
errors, in C++ too.

While `static_cast` requires a generic pointers as intermediate, there is even
a stronger tool (say sledge-hammer?) which directly fits together what really
shouldn't fit:
```
int *ip;
…
float *fp = reinterpret_cast<float*>(ip);
```

Using pointer type conversions with `static_cast` and especially using any
conversion with `reinterpret_cast` means **a lot of responsibility** is assumed
for what is done is actually correct.

.N[
As C++ has far better language support for generic programming as C, low-level
cast operations can be avoided in most any case.._[]
]

.F[:
One of the few legitimate uses of `reinterpret_cast` is in driver programming
to specify hardware addresses for memory mapped devices.
]

---
template: plain
header: #### `const` Qualifier for Pointers

.N[
Be sure to understand how `const` applies if pointers are involved!
]

.pull-left[

The pointer itself is constant (and hence needs to be initialised):
```
T *const p = …;
```
]

.pull-right[

The memory location reachable via the pointer is constant:
```
T const *p;
```
Same as:
```
const T *p;
```
]

In some situations even both should be protected against modifications, the
pointer and the memory to which it points:._[]
```
const T *const p = …; // a unmodifiable pointer to an
                      // unmodifiable memory location
                      // of type T
```
.F[:
Of course `T const *const p = …;` would have the same meaning.
]

---
template: plain
name: references
header: ### References

References are more or less a different syntax for pointers.

* They are declared with a leading `&` – instead of a leading `*`;

* They must be initialised with some variable to which it refers,

  * i.e. the `&`-operator – take address – is implicitly applied to that
    variable.

* When used, a reference is automatically dereferenced,

  * i.e. the `*`-operator – follow pointer, get content – is implicitly
    applied.

.N[
Conceptually a reference is always connected to an existing entity –
there is no such thing as a "Null Reference" akin to a "Null Pointer".._[]
]

.F[:
Nevertheless, an incautious programmer may accidentally create invalid
references, e.g. like that:  
`void f(T *p) { …; T &r = *p; … }` (when `p` is not checked against the
Null Pointer)
]

---
template: plain
header: #### References Viewed as Aliases

A reference may also be viewed as an alias for an existing variable:
```
int i;
…
int &r = i;   // any access to r effectively accesses i
```

.N[
The main use for this feature is for function arguments, where it minimises the
syntactical overhead of explicit pointer use.
]

---
template: plain
header: #### References versus Pointers

Two function that swap their argument values, one using pointers, one using
references …

.pull-left[
```
void swap(int *p1, int *p2)
{
    int tmp = *p1;
    *p1 = *p2;
    *p2 = tmp;
}
```
]

.pull-right[
```
void swap(int &r1, int &r2)
{
    int tmp = r1;
    r1 = r2;
    r2 = tmp;
}
```
]

… and their usage:

.pull-left[
```
int a, b;
…
if (a < b)
    swap(&a, &b);
```
]

.pull-right[
```
int a, b;
…
if (a < b)
    swap(a, b);
```
]

---
template: plain
header: #### `const`-References

As references cannot be changed after initialization._[] they really are like
`const` pointers – but this should not be confused with pointers to `const`:

.pull-left[
```
const int ci = 42;
int i;
int &ri = i;         // OK
const int &cri = ci; // OK
const int &cri2 = i; // OK
ri = …;    // OK to modify
cri2 = …;         // ERROR
int &ri2 = ci;    // ERROR
```
]

.pull-right[
```
const int ci = 42;
int i;
int *const ip = &i;
const int *const cip = &ci;
const int *const cip2 = &i;
*ip = …;   // OK to modify
*cip2 = …;        // ERROR
int *ip2 = &ci;   // ERROR
```
]

Any access to `ri`, `cri`, and `cri2` actually accesses the referenced
variable, while applying `&` takes the address of it. Vice versa with pointers:
here the plain variable usage represents the address held and applying the
dereferencing operator `*` accesses the content of that memory location.

.F[:
To put it more clearly: a reference refers to the same storage location all of
its lifetime, like a pointer that cannot be set to a different location. A
different question is whether the storage location *reachable* through the
reference can be modified – and this is what this page is about.
]

---
template: plain
header: #### Lvalue- and Rvalue-References

A special property of `const` references is that they may be initialised with
temporaries, typically resulting from an expression of matching type:._[]

.pull-left[
```
int a, b;
…
int &r = a;            // OK
int &r2 = a + b;       // ERROR
const int &r3 = a + b; // OK
```
In the last case temporary memory space must be created – for the result of the
addition – and will be kept alive for the life-time of the reference.
]

.pull-right[
A recent addition of C++11 are [Rvalue References].  
**These can only be initialised with temporaries.**
```
int &&rr = a + b; // OK
int &&rr2 = a;    // ERROR
int &&rr3 = a + 0;   // OK
```
.N[
The main use of rvalue-references is to add move-versions of (copy-)
[constructor](#move_constructor) and [assignment](#move_assignment), which
will be covered later.
]
]

[Rvalue References]: http://en.cppreference.com/w/cpp/language/reference

.F[:
Early versions of C++ allowed this for non-`const` references too but it
turned out to be an error prone feature and was finally removed in later
versions of C++ on which C++-98 was based.
]

---
template: plain
header: #### When to Use References?

References should be generally preferred as function arguments for

* handing over  anything else besides basic types efficiently, as only an
  address needs to be transferred, not all of the data structure copied;
* giving access to the object itself for applying modifications.

.N[
Use a `const` qualified reference to protect some function argument from
modifications while – behind the scenes – only handing-over its address.
]

.pull-left[

[ADT]._[] to implement a counter that
restarts at a given value once
it had reached a given limit:
```
typedef struct {
    int limit; // maximum value
    int start; // restart value
    int ticks; // current value
} counter;
```
]

[ADT]: http://www.youtube.com/watch?v=HcxqzYsiJ3k


.pull-right[
```
int value(const counter &c) {
    return c.ticks;
}
```
```
void count(counter &c) {
    if (++c.ticks > c.limit)
        c.ticks = c.start;
}
```
]

.F[:
ADT means abstract data type and (in the example above) comes close to what can
be done with classes in C++. (In a "pure C" solution references can be easily
replaced by pointers.)
]

---
template: plain
name: default_args
header: ### Default Arguments

Function arguments can have defaults, which means that the actual call can
leave out such arguments.._[]

```
void say_hello(const char *greet = "hello") {
    cout << greet << endl;
}
```
Possible calls:
```
say_hello();
say_hello("salve");
```

The default value must be present in a prototype that declares the function and
in this case the argument name is optional:
```
extern void say_hello(const char * = "hello");
```

.F[:
C++ still has no named arguments (like eg. Python) but with a due amount of
boilerplate code such a mechanism may be built like described here:
https://isocpp.org/wiki/faq/ctors#named-ctor-idiom
]

---
template: plain
name: function_ovld
header: ### Function Overloading

Functions may be overloaded based on their signature, which consists of

* the function name and argument list
* but **not** the function return type.

```
void say_hello(const char *greet) {
    cout << greet << endl;
}
void say_hello(int repeat, const char *greet) {
    do
        cout << greet << endl;
    while (--repeat > 0)
}
```
Possible calls:
```
say_hello("hi!");
say_hello(3, "hi!");
```

---
template: plain
name: operator_ovld
header: ### Operator Overloading

Operators may be overloaded too, but only if at least one of operand is not a
basic type.._[]
```
enum Color { Red, Blue, Green };
Color operator++(Color& c) {
    switch (c) {
        case Red: return c = Blue;
        case Blue: return c = Green;
        case Green: return c = Red;
        default: assert(!"never executed");
    }
}
```

.F[:
For basic types operators are already defined – or forbidden – and that meaning
cannot be changed.
]

---
template: plain
name: oop_intro
header: ## Object Oriented Programming

This chapter introduces not a minor but a substantial extensions C++ has over
C, using a "limit counter" implemented as abstract data type as an example that
gets gradually extended.._[]

* [From `struct` to `class`	](#struct_to_class)
* [Access Protection		](#access_protection)
* [Constructors			](#constructors)
* [Base and Derived Classes	](#base_and_derived)
* [`virtual` Member Functions	](#virtual_members)

.N.center[
At the low-level C++ classes still are
[data `struct`-ures mapped to memory](#class_to_memory), while *Composition*
and *Inheritance* are more or less nested data structures with some specific
rules for type (in-) compatibility.
]

.F[:
There are generally two roads leading to C++, the first one, which is taken
here, *step by step* turns C style programming into making use of classes and
objects. The other road would radically cut off with all *"traditionally
thinking"* and especially all *"old code"* and mandate a *"completely different
approach"* from *"classic procedural design"*. It will often start with
teaching design methodology, probably via the use of
[UML Diagrams](#quick_uml). Though some proficiency with the latter will surely
pay to document [OOP High-Level Designs](#class_design) it is **not at all**
necessary to get substantial added value by a move from C to C++.
]

---
template: plain
name: struct_to_class
header: ### From `struct` to `class`

#### Turning Functions into Members

C++ allows to define functions that take a pointer to a `struct` as (first)
argument inside the class as members (aka. member functions):._[]
```
struct LimitCounter {
    int start;
    int limit;
    int ticks;
    void init(int st, int lim);
    void count();
    void reset();
};
```

.F[:
A plain C example using just a `struct` and define the functions to access it
outside can be found here: http://coliru.stacked-crooked.com/a/b2ce4b96d9725055
]

.N[
The argument to hand over the limit counter data is now implied and not named
any more in the list of arguments.
]

---
template: plain
header: #### Defining `LimitCounter` Objects

Objects (aka instances) of limit counters would be defined as follows:
```
    LimitCounter lc1, lc2;
```

#### Calling Member Functions

When calling the member function syntactically the object is on the left:
```
    lc1.init(1, 10);
    lc2.init(0, 59);
```

.N[
From a low-level point of view there is no difference to a global function with
an explicit pointer argument, as the address of the objects `lc1` and `lc2` is
received by the member function as `this` (-pointer).
]

---
template: plain
header: #### Implementing Member Functions

Of course, the function inside the class are just declarations that must be
implemented too. This would look like follows:
```
void LimitCounter::init(int st, int lim) {
    this->start = this->ticks = st;
    this->limit = lim;
}

```
As `this->` is assumed by default for any name that is not local or part of the
argument list, it is usually omitted:
```
void LimitCounter::count() {
    if (++ticks > limit)
        ticks = start;
}

```

---
template: plain
header: #### Implementing Member Functions Inline

For efficiency reasons it usually makes sense to define small member functions
wtih the `inline` keyword so that their body code is inserted instead of
subroutine calls at the point of their use:
```
inline
void LimitCounter::reset() {
    ticks = start;
}
```
.N[
Then a "call" to this (simple) function like `lc1.reset()` will typically
result in a single `mov` instruction at the machine level, which is both,
faster **and** smaller as a subroutine call!
]

---
template: plain
header: #### Implementing Members Inside the Class

Furthermore `inline` is automatically assumed if the function is implemented
inside the class to which it belongs:
```
struct LimitCounter {
    …
    void reset() {
        ticks = start;
    }
    …
};
```
Whether to use this or an explicit `inline` with an implementation outside of
the class is largely a matter of taste.

.N[
When classes are – as usual – defined in separate header files, `inline`
implementations **must go to the header file** because the compiler needs to
know them when it emits the code for a "function call".
]

---
template: plain
name: access_protection
header: ### Access Protection

It is usually considered "good style" if a user defined type protects its data
members from direct access but adds accessors instead:
.pull-left[
```
class LimitCounter {
    int start;
    int limit;
    int ticks;
public:
    …
    int value() const {
        return ticks;
    }
    void count() {
        if (++ticks > limit)
            ticks = start;
    }
};
```
]

.pull-right[
The `const` qualifier for the member function – between the closing parenthesis
and the opening curly brace – allows to call this function for non-modifiable
`LimitCounter` instances:
```
void
foo(const LimitCounter &c) {
    cout << c.value(); // OK
    c.count();      // ERROR
}
```
]

.F[:
There are several common naming schemes for such accessors. A project should
probably chose one of this schemes and apply it consistently for all its
classes.
]

---
template: plain
name: protection_levels
header: #### Levels of Access Protection

There are several protection levels which can be interspersed as often as
necessary with the members in `struct`- or `class`-blocks like labels:._[]

* `public:` – accessible from outside
* `private:` – accessible for member functions only
* `protected:` – accessible for member functions and
  [derived classes](#base_and_derived) (covered later)

.pull-left[
```
class Mine {
public:
    …
protected:
    …
private:
    …
};
```
]
.pull-right[
```
class Other {
    …
public:
    …
private:
    …
public:
    …
};
```
]

.F[:
Despite the similar syntax these are **not** labels, as the names are reserved
keywords and the syntax limits their use to `struct` and `class` blocks.
]

---
template: plain
name: struct_vs_class
header: #### `struct` vs. `class`

The only difference between `class` and `struct` is that the latter starts by
default with a `public:` section and the former with a `private:` section.
.pull-left[
```
struct Mine {
private:
    …
public:
    …
};
```
```
struct Other {
    …
private:
    …
};
```
]

.pull-right[
```
class Mine {
    …
public:
    …
};
```
```
class Other {
public:
    …
private:
    …
};
```
]

---
template: plain
name: constructors
header: ### Constructors

Classes may have Constructors which will – if they exist – be called
automatically when an instance of the given class comes into existence:
```
class LimitCounter {
    …
public:
    LimitCounter(int st, int lim) {
        start = ticks = st;
        limit = lim;
    }
};
```
Constructor arguments must now be supplied with the definition of instances:
```
    LimitCounter lc1(1, 10), lc2(0, 59);
```

---
template: plain
name: constructors
header: #### Constructors: Member Initialisation Lists

There is an alternative syntax to initialise data members, the *MI-list* (short
for member initialisation list). Its use is mandatory when constants and
references are initialised, but they may optionally be used always:
```
class LimitCounter {
    const int start;
    const int limit;
    int ticks;
public:
    LimitCounter(int st, int lim)
        : start(st), limit(lim), ticks(st)
    {}
    …
}
```
.N[
It is not at all unusual that – when the MI-list is used for all members – the
constructor body stays empty.._[]
]

.F[:
Of course, to maximize consistency by re-use, it might alternatively be
considered in the above example to initialise `ticks` with a call to `reset()`
from inside the constructor body.
]

---
template: plain
name: destructor
header: ### Destructors

The destructor is the complementary operation to the constructor.  

It has the same name as the class prefixed with `~` and will automatically be
called if an instance of the given class ceases to exist.

There is no need for a destructor in the `LimitCounter` class.

.N[
An example for a class that actually needs a destructor follows in the section
on [Dynamic Memory Allocation](#dynamic_memory).
]

---
template: plain
name: static_members
header: ### Static Members

Member variables and functions may be ´static`, which means they exist only
once (for the class), not for every instance.

As there is no need for static members in the `LimitCounter` example, the
following shows how a class could count the number of its instances:._[]

.pull-left[
In the header defining the class:
```
// file: Foo.h
class Foo {
    …
    static int instances;
public:
    Foo() { ++instances; }
    ~Foo() { --instances; }
    …
};
```
]
.pull-right[
In exactly one translation unit:
```
// file: Foo.cpp
…
int Foo::instances = 0;
…
```
]

.F[:
This example is actually incomplete as it omits the copy constructor (not
covered so far) which would also need to be implemented as it must increment
the `instances` count too.
]

---
template: plain
name: base_and_derived
header: ### Base and Derived Classes

Classes may be derived from other classes if they only want to extend some
existing functionality.

.N[
The following defines a new class `OverflowCounter` which adds to a
`LimitCounter` the capability that in case of an overflow it increments a
connected counter.
]

The approach is shown step by step on the next pages.

---
template: plain
name: base_and_derived
header: #### Derive from a Base Class

The syntax names the base class after the derived:
```
class OverflowCounter : public LimitCounter {
    …
};
```
The use of `public` here implies that an `OverflowCounter` can always replace a
`LimitCounter`, which will become important soon.._[]

Technically the principle of substitutibility mean there is an automatic type
conversion from the derived to the base class.

.N[
According to Barbara Liskov, who first formulated that principle, it is also
named [Liskov Subsitution Principle] or LSP in short.
]

[Liskov Substitution Principle]: https://en.wikipedia.org/wiki/Liskov_substitution_principle

.F[:
If this kind of substitutability is not desirable, a `private` base class
should be used.
]

---
template: plain
header: #### Implementation and Consequences of the LSP

If the data members of the base class are put first into the data structure of
derived class, implementing the LSP effectively is a no-op at run-time:

* A pointer to a derived class also points to the members of the base class
  (as such have the same offset in the structure)

* Same for a reference to the base class vs. a reference of the derived class,
  as behind the scenes references are implemented as pointers.

* When a value of the derived class initializes or is assigned to a value of
  base class, only the base class members are actually assigned.

.N[
By default all public members (data and functions) of the base class are
visible as members of the derived class.
]

Typically, but not necessarily, a derived class **extends** the base class
with more member data and functions, beyond what was "inherited" from the
derived class.

---
template: plain
header: #### Overwriting Inherited Implementations

A derived class may **override** implementations of member
functions.

.N[
Usually derived classes **do not** something arbitrary and completely different!
Rather they will **extend** the inherited implementation.._[]
]

In most practical implementations this means the base class needs to
"cooperate" to a degree, e.g.

* accept (slightly) [suboptimal run-time behavior](#suboptimal_reuse);

* [reduce protection](#reduce_protection) of members wrt. to derived
  classes (by making them `protected:` instead of `private`);

* [give hints](#giving_hints) to derived classes beyond the needs of its direct clients;

* chose to use a design with [pre-planned extension points](#extension_points)
  instead of overwriting a global function (aka. [Non-Virtual Interface] or NVI
  Idiom).

[Non-Virtual Interface]: https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-Virtual_Interface

.F[:
To stay within the limits in which a derived class may "alter" the base class
implementation, be sure to understand the principle or *Pre-Conditions* and
*Post-Conditions* as outlined here:  
https://isocpp.org/wiki/faq/proper-inheritance
]

---
template: plain
header: #### Add Member Data

A derived class is always free to add member variables and functions._[]
to what is inherited from its base class.

.N[
The `OverflowCounter` needs to add a reference to the next stage (which will
count on overflow).
]

```
class OverflowCounter : public LimitCounter {
    LimitCounter &next;
};
```

Note that

* an object of type `OverflowCounter` **contains all the data** that belongs to
  a `LimitCOunter`

* but the `LimitCounter` object reachable via `next` **is a different instance**
  than the one contained because of its `LimitCounter` base class.

.F[:
So far in this example no member functions are added.
]

---
template: plain
header: #### Add A Constructor

To initialise data members added, a derived class usually needs its own
constructor.

```
class OverflowCounter : public LimitCounter {
    LimitCounter &next;
public:
    OverflowCounter(int st, int lim, LimitCounter &n)
        : LimitCounter(st, lim), next(n)
    {}
    …
};
```

.N[
The constructor forwards its first two arguments to the constructors of its
`LimitCounter` base class and uses the third (reference) argument to initialise
`next`.._[]
]

.F[:
Clearly there is the need for different constructor when the derived class
adds data members, as such need to be initialized too.  If the base class has
"a whole bunch of constructors" which all make sense for the derived class too
this can turn into an substantial of work. In C++11 several new features come
to relieve, like *Direct Member Initialisation*, *Constructor Inheritance and
Delegation*, and *Variadic Templates* combined with *Perfect Forwarding*.
**These are only demonstrated on demand.**
]

---
template: plain
header: #### Add Another Member Function

Of course, an `OverflowCounter` has a slightly different way to count compared
to a `LimitCounter`:
```
class OverflowCounter : public LimitCounter {
    LimitCounter &next;
public:
    …
    void count();
};
```

.N[
So far this only declares the **intent** to implement `count()` **differently**
from the inherited implementation.
]

---
template: plain
name: suboptimal_reuse
header: #### OverflowCounter Overwriting `count`

Now it needs to replace the inherited `count()` member function.._[]

```
void OverflowCounter::count() { // overriding inherited count
    int old = value();     // getting inherited value()
    LimitCounter::count(); // calling inherited count()
                           // (qualification necessary here
                           // to avoid recursive call !!)
    if (value() < old)
        next.count();  // calling next stage `count()`
}
```
.N[
Looking closely shows that semantically this also **extends** the
implementation inherited.
]

While this solution works, it looks (and is) clumsy, but any improvement would
mean that the base class needs to take into account the needs of its derived
class.

.F[:
The technical term here is "overriding", though in German literature this is
often translated with "überscheiben" (= overwriting).
]

---
template: plain
name: reduce_protection
header: #### Reducing Protection of Members

One possibility for a more elegant way would be a reduced protection of its
`start` or `limit` data member. The following makes it accessible for a derived
class:
.pull-left[
```
class LimitCounter {
    …
protected:
    const int start;
    …
}
```
The solution still looks clumsy:
```
void OverflowCounter::count() {
    LimitCounter::count();
    if (value() == start)
        next.count();
}
```
]
.pull-right[
```
class LimitCounter {
    …
protected:
    …
    const int limit;
}
```
Or alternatively:
```
void OverflowCounter::count() {
    if (value() == limit)
        next.count();
    LimitCounter::count();
}
```
]

.F[:
The full example can be found here:
http://coliru.stacked-crooked.com/a/e69477f058f431ab
]

---
template: plain
name: giving_hints
header: #### Giving Hints to From Base Classes

Another possibility were to have the base class give a hint to the derived
class.

In the scenario used as example so far this hint could be the return value of
the `count` member function:
```
bool LimitCounter::count() {
    if (++ticks > limit) {
        ticks = start;
        return true;
    }
    return false;
}
```

---
template: plain
header: #### Using Hints in Derived Classes

The derived class would now make use of this hint …
```
bool OverflowCounter::count() {
    if (LimitCounter::count()) {
        next.count();
        return true;
    }
    return false;
}
```
… but assuming it may in turn be used as base class from some derived class
that needs this hint, it has to forward it accordingly via its own return
value.

.N.center[
Still not a really nice solution!
]

.F[:
The full example can be found here:
http://coliru.stacked-crooked.com/a/57e620c867233fed
]

---

template: plain
header: #### A Chain of Counters

Now consider the case that a chain of counters is build, e.g. as display of a
clock:
```
int main() {
    LimitCounter hours(0, 23);
    OverflowCounter minutes(0, 59, hours);
    OverflowCounter seconds(0, 59, minutes);
    …
    // probably in a loop ...
        seconds.count();
    …
}
```
The fact that the "middle" counter (`minutes`) can be used as constructor
argument for another `OverflowCounter` is worth mentioning here:

.N[
It is only possible because the `OverflowCounter` has the `LimitCounter` as
`public` base class and therefore – as an instance of the derived class – the
former is always accepted as a substitute for the latter.
]

.F[:
The full example can be found here:
http://coliru.stacked-crooked.com/a/59c721aa3218086b
]

---
template: plain
name: virtual_members
header: ### `virtual` Member Functions

.W[
Actually the chained counter example will not work unless `count()` is declared
`virtual` in the base class `LimitCounter`.
]

In C++ member functions are not `virtual` by default as

* [**calling** a `virtual` Member function](#virtual_mfn_call) comes at the
  cost of an indirection;

* a `virtual` member function typically can not be expanded inline,

  * leading to a substantial performance penalty on modern hardware with fast
    local instruction caching and pre-fetch mechanisms,

  * especially for small functions which otherwise are often desirable for
    modularity and other reasons.

.F[:
Another examples for the use of virtual member functions follows in the next
section, applying an idiom known as *Non Virtual Interface*. Besides that there
is an example in the optional Info-Graphics.
It covers [type-dependant branching](#practical_rtti) and also explains how
this usually relates to a `virtual` member functions "missing per design".
]

---
template: plain
header: #### Compile-Time vs. Run-Time Types

For a slightly more general point of view with respect to `virtual` member
functions the difference between 'Compile-Time Type` and `Run-Time Type` needs
to be understood.._[]

* The compile-time of member `next` in `OverflowCounter` is `LimitCounter`.

.N[
Calling a **regular** (non-`virtual`) member function on `next` will resolve to
the implementation provided by class **`LimitCounter`**.
]

* At run-time the type may
  * actually be a `LimitCounter` (as it is for `minutes`), or
  * or anything derived from it (as it is for `seconds`).

.N[
Calling a **`virtual`** member function on `next` will resolve to the
implementation provided by class **`OverflowCounter`**.
]

.F[:
That difference also shows up in [Run-Time Type Identification] (or RTTI in
short) which since C++98 can be done with either `typeid` or `dynamic_cast` and
is only covered here on demand.
]

---
template: plain
name: extension_points
header: #### Add Extension Points in the Base Class

A far superior solution is possible if the base class (`LimitCounter`) had
anticipated the needs of its derived classes and added an extension point:
```
class LimitCounter {
    …
    virtual void overflow() {}
public:
    void count();
    …
};
```
The base class does nothing in this case – except calling a function that
returns immediately:
```
void LimitCounter::count() {
    if (++ticks > limit) {
        overflow();
        ticks = start;
    }
};
```

---
template: plain
header: #### Hooking Code to Extension Points from Derived Classes

This would be the **full** code of the class `OverflowCounter` then:
```
class OverflowCounter : public LimitCounter {
    LimitCounter &next;
    virtual void overflow() override {
        next.count();
    }
public:
    OverflowCounter(int st, int lim, LimitCounter &n)
        : LimitCounter(st, lim), next(n)
    {}
};
```
Especially now there is no need any more to override the `count()` member function
inherited from `LimitCounter`.

.N.center[
Instead the function for the extension point is overridden.._[]
]

.F[:
An advantage achieved thereby is that it cannot be forgotten to call the
inherited function from the overwritten one.
]

---
template: plain
header: #### The "Open-Close Principle"

* *Extension Points*s

 as shown so far can also be viewed as an application of the

* *Template Method*

design pattern outlined by the [GoF-Book].

.N[
From a more general point of view this is the [Open-Closed Principle]._[] as
defined 30 years ago by Bertrand Meyer and still alive today …._[]
]

[Open-Closed Principle]: https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle

It is illustrated in an optional [Info-Graphic](#two_open_closed) which shows

* an approach with C++-Templates

* besides the typical approach with `virtual` member functions.

(The latter according to the *Template Method Pattern*, covered in more depth
by books dealing with *OOP Design Patterns*, like the [GoF-Book].)

[GoF-Book]: https://en.wikipedia.org/wiki/Design_Patterns

.F[:
… as the "O" in the set of "SOLID" Principles (with "L" in representing the
Liskov Substitution Principle.)
]


---
template: plain
name: alternative_design
header: ### Alternative Design

An alternative design could use **one class only** that is similar to the
`OverflowCounter` used so far. The difference is that it connects the next
counter – the one which counts on overflow – via the member `pnext` which is a
pointer and is a null pointer if there is no next counter attached.
```
class OverflowCounter {
    const int start;
    const int limit;
    int ticks;
    OverflowCounter *pnext;
public:
    OverflowCounter(int st, int lim, OverflowCounter *pn = 0)
        : start(st), limit(lim), pnext(pn)
    {}
    void count() {
        if ((++ticks > limit) && (pnext != 0))
            pnext->count();
    }
    …
};
```

---
template: plain
name: exception_intro
header: ## Introduction to Exceptions

[Basically exceptions are](#exception_basics)

* non-local branches,

* backwards in the call tree,

* to a `catch`-block in a function that has not yet returned,

* and its preceding `try`-block active.._[]

.F[:
Some more specific information on exceptions is provided in an separate
[Info-Graphic](#exception_specifics).
]

---
template: plain
name: exception_throw
header: ### Throwing Exceptions

A `throw` statement is used to terminate current processing.

It needs to be followed by an expression, which has a type and a value.._[]

* Sometimes basic types are used as exceptions,
* but typically a class (or small class hierarchy) is defined for that
  purpose.

```
… throw 42;                 // integer thrown
… throw "let me out here!"; // const char* thrown
… throw ErrorX(12, 15);     // instance of class ErrorX thrown
```

.F[:
A `throw`-statement usually is only conditionally, i.e. when a certain
condition is detected that prevents following the ordinary flow of control any
further.
]

---
template: plain
name: exception_throw
header: ### Catching Exceptions

The `catch` block defines a parameter which acts much like a function
argument.._[]

* Actually it receives the value of the expression thrown,
* therefore its type must be compatible with the type thrown.

Catch 42 (and other int-s):
```
try { … } catch (int x) { … }
```
Catch `"let me out here"` (and other C-style strings):
```
try { … } catch (const char* txt) { … }
```
Catch instances of class `ErrorX` and classes publicly derived from `ErrorX`:
```
try { … } catch (ErrorX &ex) { … }
```

.F[:
The examples shown here are written into a single line only to safe some space.
Usually the `try`- and `catch`-block would be formatted to extend over several
lines, as is necessary from its contents. The examples shown here are written
into a single line only to safe some space. Usually the `try`- and
`catch`-block would be formatted to extend over several lines, as is necessary
from its contents.
]

---
template: plain
name: configurable_exceptions
header: ### Configurable Exceptions

A strategy to make the throwing of exceptions configurable could be not to
throw directly but through a virtual member function:._[]
```
struct ErrorX {
    ErrorX(int, int);
};
…
class Mine {
    virtual void error_X(int, int) = 0;
public:
    void do_it() {
        …
        if (…) error_X(12, 15);
        …
    }
};
```
.F[:
As shown so far `Mine` is an abstract class which can only be used as base
class for derived classes like those shown on the next pages. Of course one of
these following classes could also serve as default implementation.
]

---
template: plain
header: ### Configurable Exceptions (2)

Instances of the following class actually throw when the error happens:
```
class ThrowingMine : public Mine {
    virtual void error_X(int a, int b) { throw ErrorX(a, b); }
}
```
Instances of this class ignore the problem:
```
class NonThrowingMine : public Mine {
    virtual void error_X(int, int) { /*empty*/ }
}
```

---
template: plain
name: dynamic_memory
header: ## Dynamic Memory Allocation

Dynamic memory (aka *heap allocation*) is requested with:

* `new T` – where `T` is any datatype, memory has sufficient size to store and
  proper alignment to store one item of type `T`;

* `new T[n]` – where T is any datatype and `n` is a positive integral number,
  memory has sufficient size ans proper alignment to store `n` items of type
  `T` as they were stored in an array.

Dynamic memory is release with:

* `delete p` – where `p` is of type pointer to `T` and has received its value
  from `new T`;

* `delete[] p` – as before but `p` has received its value from `new T[n]`.

.W[
Releasing memory that was allocated with `new T[n]` with `delete` or releasing
memory that was allocated with `new T` with `delete[]` results in undefined
behavior.
]

---
template: plain
header: ##### `RingBuffer` Example

A class RingBuffer to store `N` integers for easy FIFO-access might have the
following implementation:
```
class RingBuffer {
    int alloc;    // ORDER DEPENDENCY (1)
    int *data;    // ORDER DEPENDENCY (2)
    int iput;
    int iget;
    static int wrap(int x) { return x % alloc; }
public:
    RingBuffer(int n);
    ~RingBuffer();
    bool get(int &);
    void put(int);
    bool empty() const { return iput == iget; }
    bool full() const { return wrap(iput + 1) == iget; }
    RingBuffer(const RingBuffer &) = delete;
    RingBuffer &operator=(const RingBuffer &) = delete;
};
```

(The ORDER DEPENDENCY comment will be explained on the next page.)

---
template: plain
header: ##### `RingBuffer` Example (2)

Memory management is done from the constructor and destructor:

```
// constructor allocating dynamic memory
RingBuffer::RingBuffer(int n)
    : alloc(n+1), data(new int[alloc]), iget(0), iput(0);
{}

// destructor releasing dynamic memory
RingBuffer::~RingBuffer() {
    delete[] data;
}
```
.W[
From looking into the MI-list it seems obvious that `alloc` is initialised
prior to its use in the initialisation of `data` …
]

… but initialisation order is determined by the order of member variables in
the class definition – changing this order may break the above code.._[]

.F[:
DEPENDENCY ORDER comments in the class faithfully try to defeat this but it
might be wiser to chose a defensive and more robust style, e.g. by using `n+1`
instead of `alloc` in the initialisation of `data`.
]

---
template: plain
header: ##### `RingBuffer` Example (3)

By deleting the copy constructor and the assignment operator an object of type
`RingBuffer` may not be copied or assigned.

If the `RingBuffer` should be copyable, the implementation of the copy
constructor could look as follows:
```
RingBuffer::RingBuffer(const RingBuffer &init)
    : alloc(init.alloc), data(new int[alloc])
    , iget(init.iget), iput(init.iput) {
    std::memcpy(data, init.data, alloc*sizeof(int));
}
```
It would be called in scenarios like this:
```
void foo(RingBuffer arg); // call by value argument!
RingBuffer a(10);
…
RingBuffer b = a; // copy constructor initialises new object
RingBuffer c(a);  // b as before, only different syntax
foo(b); // copy constructor used to initialise value argument
```

---
template: plain
header: ##### `RingBuffer` Example (4)

The implementation of copy assignment operator could look as follows:
```
RingBuffer& RingBuffer::operator=(const RingBuffer &rhs) {
    if (this != &rhs) {
        alloc = rhs.alloc;
        int *tmp = new int[alloc];
        std::memcpy(tmp, rhs.data, alloc*sizeof(int));
        delete[] data;
        data = tmp;
        iget = rhs.iget;
        iput = rhs.iput;
    }
    return *this;
}
```
It would be called in scenarios like this:
```
RingBuffer a(10), b(100);
…
b = a; // copy assignment discards memory space previously
       // allocated, allocates new space and copies content
```

---
template: plain
name: move_constructor
header: ##### `RingBuffer` Example (5)

If the `RingBuffer` needs only to be movable (or as an optimization if it is
copyable and made movable in addition), the move constructor could look as
follows:
```
RingBuffer::RingBuffer(RingBuffer &&init)
    : alloc(init.alloc), data(init.data)
    , iget(init.iget), iput(init.iput) {
    init.data = nullptr;
}
```
It would be called in scenarios like this:
```
RingBuffer foo();
void bar(RingBuffer);
…
RingBuffer a = foo(); // initialization with temporary
RingBuffer a(foo());  // as before, only different syntax
bar(foo());  // value argument initialised with temporary
```

.F[:
This video by Scott Meyers gives a good introduction to moving vs. copying
(starting at [4:05]) followed what is called "perfect forwarding"
(starting at [16:05]):  
http://channel9.msdn.com/Events/GoingNative/2013/An-Effective-Cpp11-14-Sampler
]

[4:05]: https://www.youtube.com/watch?feature=player_detailpage&v=BezbcQIuCsY#t=245
[16:05]: https://www.youtube.com/watch?feature=player_detailpage&v=BezbcQIuCsY#t=965

---
template: plain
name: move_assignment
header: ##### `RingBuffer` Example (6)

Furthermore, the implementation of a move assignment operator could look as
follows:
```
RingBuffer& RingBuffer::operator=(RingBuffer &&rhs) {
    alloc = rhs.alloc;
    delete[] data;
    data = rhs.data;
    rhs.data = nullptr;
    iget = rhs.iget;
    iput = rhs.iput;
    return *this;
}
```
It would be called in scenarios like this:
```
RingBuffer foo();
…
RingBuffer a(10);
a = foo(); // move assignment discards memory space previously
           // allocated, then "steals" pointer from temporary
```

---
template: plain
header: ##### `RingBuffer` Example (7)

Only for completeness: this are the member functions that fill in or take out
elements:
```
// add an element
void RingBuffer::put(int e) {
    if (full()) iget = wrap(iget) + 1;
    data[iput] = e;
    iput = wrap(iput+1);
}
// retrieve an element
bool RingBuffer::get(int &e) {
    if (empty()) return false;
    e = data[iget];
    iget = wrap(iget+1);
    return true;
}
```

---
template: plain
name: pointers_revisited
header: ### Pointers Revisited

One of the problem with pointers that their type does reflect too little of the
use pattern.

* There are pointers that allow to access some memory that

  * exists already before the referring pointer comes into live
  * and will continue to exist when the life of the referrer ends.

* There are pointers that have exclusive ownership to dynamic memory

  * they need to `delete` when they go out of scope,
  * except they transfer ownership to some other exclusive owner.
  
* There are pointers that have non-exclusive ownership to dynamic memory that
  needs to be `delete`-ed when the life of the last of them ends.

---
template: plain
header: ### Smart Pointers

C++11 introduced new types of pointers designed to solve the problem of unique
and shared ownership:

* `unique_ptr<T>` (where `T` is any concrete type) implement the concept of
  unique ownership and therefore are not copyable but can be moved.

* `shared_ptr<T>` (where `T` is any concrete type) implement the concept of
  shared ownership maintaining a reference count.

[Smart Pointers](#smart_pointers) are provided as classes with overloaded
pointer-operations to make them usable in an easy way – **just like native
pointers**.

.N[
Knowing the principles and some intricacies of their implementation **is NOT AT
ALL a requirement** but can surely help to come to a better understanding and
also some guidelines for their correct use.
]

---
template: plain
name: std_unique_ptr
header: ##### `RingBuffer` Example with `std::unique_ptr`

If the `RingBuffer` used as example in the previous section has no requirement
to be copyable it could be simplified as follows:
```
class RingBuffer {
    int alloc;
    std::unique_ptr<int[]> data;
    …
public:
    RingBuffer(int n)
        : alloc(n+1), data(new int[alloc]), …
    …
};
```

* No explicit move constructor and assignment is necessary any more as the
  default versions do the right thing.  

* A copy constructor and assignment – doing the **wrong** thing by default – is
  **not** automatically supplied as `unique_ptr` is not copyable.

---
template: plain
name: std_shared_ptr
header: ### Beyond Unique Ownership

Besides `std::unique_ptr` C++11 added._[] two more "Smart Pointers":

* `std::shared_ptr` and

* `std::weak_ptr`

.N[
Neither of both is covered here in detail, but feel free to ask for more
information based on the [Infographic "Smart Pointers"](#smart_pointers) in the
appendix.
]

In short, both apply in scenarios which runtime systems of other programming
languages solve with [Garbage Collection] (or GC).

[Garbage Collection]: https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)

The main difference from true GC is that

* while consequently using `std::shared_ptr` solves the problem of "pointers
  going stale" (aka. "dangling references)

* in some circumstances there is still the need for a careful design mixing-in
  `std::weak_ptr` to reliably avoid memory leaks.

.F[:
C++11 also deprecated `std::auto_ptr`, which – to quote Bjarne Stroustrup –
should always have been what `std::unique_ptr` now is but couldn't, as C++98
lacked the distinction between *Move* and *Copy*.
]

---
template: plain
name: stdlib_strings_streams
header: ## Strings and Streams

Covered here are:

* [The class `std::string`](#std_string)
* [Classes for Stream Handling](#std_iostream)

[More standard library components follow.](#stdlib_stl)

---
template: plain
name: std_string
header: ### Standard String Class

[`std::string`]: http://de.cppreference.com/w/cpp/string/basic_string

The [`std::string`] is designed to be used much like a built-in type.

The following program fragment prints the largest word from its input (in
lexicographical sort order):
```
string word;
string maxword:
while (cin >> word) {
    if (maxword < word) maxword = word;
}
cout << maxword << endl;
```

.N[
As the class `std::string` is not covered in much detail here feel free to
ask for more information based on the
[Infographic "Standard Strings"](#std_string_basics) in the appendix.
]

---
template: plain
name: std_iostream
header: ### Classes for Stream Handling

Support for handling data streams – mainly dealing with the aspects of
abstraction and transparent buffering – falls into two big groups:

* [`std::istream`] and [`std::ostream`] hosting all the input and output
  operations while decoupling the actual data source or sink.

* [`std::ifstream`] and [`std::ofstream`] using a classical (external) file
  as data source or sink.

* [`std::istringstream`] and [`std::ostringstream`] using an [`std::string`] as
  data source or sink.

[`std::string`]: http://de.cppreference.com/w/cpp/string/basic_string
[`std::istream`]: http://en.cppreference.com/w/cpp/io/basic_istream
[`std::ostream`]: http://en.cppreference.com/w/cpp/io/basic_ostream
[`std::ifstream`]: http://en.cppreference.com/w/cpp/io/basic_ifstream
[`std::ofstream`]: http://en.cppreference.com/w/cpp/io/basic_ofstream
[`std::istringstream`]: http://en.cppreference.com/w/cpp/io/basic_istringstream
[`std::ostringstream`]: http://en.cppreference.com/w/cpp/io/basic_ostringstream

.N.center[
As the above classes are not covered in much detail here  
feel free to ask for more information based on  
the [Infographic "I/O-Stream Basics](#io_stream_basics) in the appendix.
]

---
template: plain
header: #### A Poor Man's Approach to TDD

Consider the following fragment that request a name as input and sends a greet
of which this name is a part:
```
void say_hello()
    string name;
    cin >> name;
    cout << "hello, " << name << endl;
}
```
The first change required is to use function arguments instead of global stream
objects:._[]
```
void say_hello(istream& in, ostream& out)
    string name
    in >> name;
    out << "hello, " << name << endl;
}
```
.F[:
Arguments of `say_hello` might actually be named `cin` and `cout` and therefore
shadow the global objects, but this is not recommended as it could quickly lead
to misunderstandings.
]

---
template: plain
header: #### A Poor Man's Approach to TDD (2)

Now some input can be prepared by using the

* `std::istringstream prepared_input`

while the output is received in the

* `std::ostringstream received_output`

and compared to the expectation:._[]
```
int main() {
    istringstream prepared_input("Mary");
    ostringstream received_output;
    // -------------------------------------------
       say_hello(prepared_input, received output);
    // -------------------------------------------
    assert(received_output.str() == "hello, Mary\n");
    cout << "** TEST PASSED **" << endl;
}
```
.F[:
Of course, a serious automated test should make sure that the answer is not
always `hello, Mary\n`, no matter what the input was … :-)
]

---
template: plain
name: template_intro
header: ## Template Introduction

Templates are available as mechanism for
[classes and functions](#template_basics) to
[parametrize types and compile time constants](#param_types_sizes).

.N.center[

Templates **avoid source code duplication**._[] when

**"*The Only Thing that Differs Is a Type*"**

(or some compile time constant)
]

An even more advanced view of templates is that they are

* Compile-Time Functions doing
* Type Transformations

finally leading to
[Template Meta-Programming](http://en.wikipedia.org/wiki/Template_metaprogramming)

.F[:
Emphasis here is on **source** code: As the "same" operations with different
types typically require different machine instructions, the total amount of
machine code is not different from a "Copy & Paste" approach with subsequent
systematic changes.
]

---
template: plain
header: ##### Template Example

A `RingBuffer` like the one used in the last series of examples might also be
useful for element types other than `int`.
```
template<typename T>
class RingBuffer {
    int alloc;
    T *data;
    int iput;
    int iget;
    static int wrap(int x) { return x % alloc; }
public:
    RingBuffer(int n);
    ~RingBuffer();
    bool get(T &);
    void put(const T&);
    …
};
```
Note that not **all** occurrences of the type `int` have been replaced, as some
are not related to the element type but used as sizes or indices!

---
template: plain
header: ##### Template Example (2)

The constructor will change as follows:
```
template<typename T>
RingBuffer<T>::RingBuffer(int n)
    : alloc(n+1)
    , data(new T[n+1]),
    , iget(0)
    , iput(0)
{}
```

.N[
Of course any function implemented outside the class – not only the constructor
– must be modified accordingly.
]

Two more examples follow on the next page.

---
template: plain
header: ##### Template Example (3)

```
template<typename T>
void RingBuffer<T>::put(const T& e) {
    if (full()) iget = wrap(iget) + 1;
    data[iput] = e;
    iput = wrap(iput+1);
}
```

```
template<typename T>
bool RingBuffer<T>::get(T &e) {
    if (empty()) return false;
    e = data[iget];
    iget = wrap(iget+1);
    return true;
}
```

---
template: plain
header: ##### Template Example (4)

If sizing the `RingBuffer` dynamically is not required, the data array could be
turned into a member variable and its size be given with another template
argument:
```
template<typename T, std::size_t N>
class RingBuffer {
    T data[N+1];
    int iput;
    int iget;
    static int wrap(int x) { return x % (N+1); }
public:
    bool get(T &);
    void put(T);
    bool empty() const { return iput == iget; }
    bool full() const { return wrap(iput + 1) == iget; }
};
```
It should be noted that this change relieves the `RingBuffer` from the memory
management burden it previously had.

---
template: plain
header: ##### Template Example (5)

The second argument now becomes also part of the member function definitions
outside the class:
```
template<typename T, std::size_t N>
void RingBuffer<T, N>::put(T e) {
    if (full()) iget = wrap(iget) + 1;
    data[iput] = e;
    iput = wrap(iput+1);
}
```
```
template<typename T, std::size_t N>
bool RingBuffer<T, N>::get(T &e) {
    if (empty()) return false;
    e = data[iget];
    iget = wrap(iget+1);
    return true;
}
```

---
template: plain
header: ##### Template Example (6)

Though the parameter `N` was not used in the member function implementations
shown so far, it is available, if necessary.

The following member function determines the count of elements stored:._[]
```
template<typename T, std::size_t N>
std::size_t RingBuffer<T, N>::size() const {
    return (iget < iput)
        ? (iput – iget)
        : (iput + N + 1 - iget);
}
```

.F[:
Of course, such a function would also need to be declared in the `RingBuffer`
class, which has been omitted here for brevity.
]

---
template: plain
header: #### Using Templates for Policies

To pick up the example of the chapter on exceptions, here is another
possibility shown how a client may determine the error handling policy of class
`Mine`, using a template-based policy.

The `ErrorPolicy` private base class encapsulates the decision how to handle
the error:
```
template<class ErrorPolicy>
class Mine : private ErrorPolicy {
    using ErrorPolicy::error_X;
public:
    void do_it() {
        …
        if (…) error_X(12, 15);
        …
    }
};
```

---
template: plain
header: #### Using Templates for Policies (2)

Following are two examples for concrete policies:
```
class ThrowingPolicy {
    void error_X(int a, int b) { throw ErrorX(a, b); }
};

class NonThrowingPolicy {
    void error_X(int, int) { /*empty*/ }
};
```
Throwing and non-throwing versions of class `Mine`:
```
using ThrowingMine = Mine<ThrowingPolicy>;
using NonThrowingMine = Mine<NonThrowingPolicy>;
```
.N[
The advantage here is that especially in the non-throwing variant the empty
function will generate no code at all, while with virtual member functions
there would be a jump into a subroutine that just returns immediately.
]

---
template: plain
name: meta_programming
header: #### Template Meta-Programming

As an advance example to motivate the necessity of meta-programming, look at
the argument of the `RingBuffer::put` member function:
```
template<typename T, std::size_t N>
class RingBuffer {
    …
    void put(const T &e);
    …
};
```
Using a constant reference here is a safe choice but not a good solution in
every case – in fact, small basic types are better handed over by value.

.N[
What we would need were a function that turns the (generic) template argument
`T` into either a `const T&` (for the general case) or leave it at `T`
(especially for small basic types).
]

---
template: plain
header: #### Boost Call Traits

Such a compile time function already exists (in a utility library of the
[Boost Platform]) and would be used as follows:._[]
```
template<typename T, std::size_t N>
class RingBuffer {
    …
    void put(typename boost::call_traits<T>::param_type e);
    …
};
```

[Boost Platform]: http://www.boost.org

.F[:
Only in case you are curious for the implementation, the basic strategy is
laid-out here:

```

// first handle the general case – by default use a constant reference:
template<typename T> struct call_traits { typedef const T& param_type; };
// then template specializations for small types: bool, char, short, ...
template<> struct call_traits<bool> { typedef T param_type; };
template<> struct call_traits<char> { typedef T param_type; };
template<> struct call_traits<short> { typedef T param_type; };
…
// then maybe partial specialization for pointer types:
template<typename T> struct call_traits<T*> { typedef T param_type; }
```
]

---
template: plain
name: stdlib_stl
header: ## STL (Containers and Algorithms)

Useful library components for common data structures and algorithms are:

* [Container Classes from the STL](#stl_containers)

* [Algorithms from the STL](#stl_algorithms)

---
template: plain
name: stl_containers
header: ### Container Classes from the STL

The STL is [designed around *Containers* and *Algorithm*](#stl_design_overview)
with an *Iterator Abstraction* as glue between the former.

The container classes provided fall into two big categories:

* [Sequential Containers](#sequential_containers)

* [Associative Containers](#associative_containers)

.N[
In C++ the term container class denotes a class which is capable to store
object (instances) of some other class.
]

---
template: plain
name: sequential_containers
header: #### Sequential Containers

The following five containers store their elements as sequence:._[]

* [`std::vector`] – contiguously stored objects (like in an native array) with
  providing random access and insertion/removal **at one end** with O(1)
  performance; existing elements are copied or moved to newly allocated memory,
  if necessary.

* [`std::list`] – non-contiguously stored objects with two links per element,
  providing insertion/removal with O(1) performance **anywhere** (even for
  other lists).

* [`std::deque`] mixture of the above (objects store in array-like chunks),
  combining random access and insertion/deletion at **both ends** (but not in
  the middle.

* [`std::array`] – light-weight wrapper providing sequential container
  for native arrays.

* [`std::forward_list`] – non-contiguously stored objects with one link per
  element, providing less overhead for small payload per element.

.F[:
The last two have been added with C++11.
]


[`std::vector`]: http://en.cppreference.com/w/cpp/container/vector
[`std::list`]: http://en.cppreference.com/w/cpp/container/list
[`std::deque`]: http://en.cppreference.com/w/cpp/container/deque
[`std::array`]: http://en.cppreference.com/w/cpp/container/array
[`std::forward_list`]: http://en.cppreference.com/w/cpp/container/forward_list

---
template: plain
name: associative_containers
header: #### Associative Containers

The following containers store their elements as a binary tree for quick look-up:

* [`std::set`] – "key"-only container without duplicates, providing look-up
  with O(log(N)) performance;
* [`std::multiset`] – as before but allowing duplicates.

<!-- -->

* [`std::map`] – "key-value"-pair container without duplicates, providing
  look-up with O(log(N)) performance;
* [`std::multimap`] – as before but allowing duplicates.

The following containers store their elements a hash-based bucket-chain
structure:

* [`std::unordered_set`] – "key"-only container without duplicates, providing
  element-lookup with O(1) performance;
  performance for element look-up;
* [`std::unordered_multiset`] – as before but allowing duplicates.

<!-- -->

* [`std::unordered_map`] – "key-value"-pair container without duplicates,
  providing element look-up with O(1) performance;
* [`std::unordered_multimap`] – as before but allowing duplicates.


[`std::set`]: http://en.cppreference.com/w/cpp/container/set
[`std::multiset`]: http://en.cppreference.com/w/cpp/container/multiset
[`std::map`]: http://en.cppreference.com/w/cpp/container/map
[`std::multimap`]: http://en.cppreference.com/w/cpp/container/multimap
[`std::unordered_set`]: http://en.cppreference.com/w/cpp/container/unordered_set
[`std::unordered_multiset`]: http://en.cppreference.com/w/cpp/container/unordered_multiset
[`std::unordered_map`]: http://en.cppreference.com/w/cpp/container/unordered_map
[`std::unordered_multimap`]: http://en.cppreference.com/w/cpp/container/unordered_multimap

---
template: plain
name: stl_iterators
header: #### Generic Container Iterators

All STL containers provide iterators, abstracting the way to pass over all
contained elements.

A basic code fragment using iterators is sketched below:
```
vector<int> data;
…
for (vector<int>::iterator it = data.begin();
                           it != data.end(); ++it)
    … *it … // access element via dereferenced iterator
```

Using the new meaning of the keyword `auto` as defined by C++11 this could
slightly abbreviated:._[]
```
for (auto it = data.begin(); it != data.end(); ++it) …
```

.F[:
To forward iterate over all the content of a container, a C++11 range-based
loop is even more compact:  
`for (auto x : data) … x … // access element via placeholder x`
]

---
template: plain
name: map_iterators
header: #### Iterating Over Maps

When iterating over a map, the iterator represents an `std::pair` of the key
and the associated value. The following is a program that counts the number of
occurrences of all the words in some text:._[]
```
#include <iostream>
#include <map>
#include <string>
using namespace std;
int main() {
    map<string, int> words;
    string w;
    while (cin >> w)
        ++words[w];
    for (auto it = words.cbegin(); it != words.cend(); ++it)
        cout << it->first << ": " << it->second << endl;
}
```

.F[:
In the first book about the C Programming Language by B.Kernighan and
D.M.Ritchie this program served as demonstration for handling dynamic data
structure and had a total of approximately 100 lines.
]

---
template: plain
name: stl_algorithms
header: ### STL Algorithms

The STL specifies a number of algorithms for some typical processing
requirements of elements in a container.

The following fragment could be used to sort the contents of a container:
```
vector<int> data;
…
sort(data.begin(), data.end());
```

.N[
It is a common property of all algorithms that a container is specified by a
pair of iterators.
]

---
template: plain
name: stl_algorithms
header: #### Output to Containers

Some algorithms allow to store their output in another container. Often a
"cookbook"-style approach makes sense:
```
int arr[100];
… // fill in n elements
std::vector<int> data;
std::unique_copy(&arr[0], &arr[n], std::back_inserter(data));
```

---
template: plain
name: inside_algorithms
header: #### Algorithms – A Look Inside

To really understand STL algorithms it makes sense to have a short look on the
implementation of a typical example:._[]

```
template<typename InIt, typename OutIt, typename Pred>
OutIt filter(InIt from, InIt upto, OutIt dest, Pred pred) {
    while (from != upto) {
        if (pred(*from))
            *dest++ = *from;
        ++from;
    }
    return dest;
}
```

.N[
An algorithm like this is available as `std::copy_if` since C++11.._[]
]

.F[:
In C++98 it seemed to be missing but what you can do with `std::copy_if` was
already possible with `std::remove_copy_if` and the predicate negated, so
`filter` from above might also be implemented as:
```
  template<typename InIt, typename OutIt, typename Pred) {
OutIt filter(InIt from, InIt upto, OutIt dest, Pred pred) {
    return std::remove_copy_if(from, upto, dest, [pred](const auto& e) {return !pred(e);});
    //          so that you don't miss the important thing - it's HERE --------^
}
```
]
---
template: plain
name: stl_algorithms
header: #### Specifying Predicates

There are many algorithms like `filter` requiring a predicate,
e.g.:._[]
```
// count all elements in `arr` with positive values:
bool gt_zero(int x) { return (x > 0); }
…
auto n = count_if(&arr[0], &arr[n], gt_zero);
```

The basic technique is always the same:
```
// copy all non-zero elements from `arr` to `data`:
bool non_zero(int x) { return (x != 0); }
…
filter(&arr[0], &arr[n], std::back_inserter(data), non_zero);
```

.F[:
While the above example code uses classic functions an alternative technique in
widespread use would define the predicate as *Function Object* (or *Functor* in
short):  
```
  // note object construction by appending `()` when the functor's type is used further below!
struct GtZero { bool operator()(int x) { return (x > 0); }};
struct NonZero { bool operator()(int x) { return (x != 0); }};
…
auto n = count_if(&arr[0], &arr[n], GtZero());    // or GtZero{} or NonZero{}  with C++11
filter(&arr[0], &arr[n], std::back_inserter(data), NonZero()); // uniform initialization
```
]

---
template: plain
name: cpp11_lambdas
header: #### C++11 Lambdas

[Lambdas]: http://en.wikipedia.org/wiki/Anonymous_function

Introducing [Lambdas] with C++11 was a major step to bring C++ at level with
many other modern programming languages, in which

* functions not only were made *"First Class Citizens"* but

* it is also possible to specify a function body **at its point of use**,._[]
  especially as argument to some other function call.

.F[:
This is why lambdas are also known as *Function Literals*.
]

.N[
The general definition syntax

* starts with a capture list in square brackets,

* followed by an argument list in round parenthesis,

* followed by the function body in curly braces.
]

---
template: plain
name: lambda_definition_syntax
header: ##### Lambda 101 – Definition Syntax Example

For the `filter` algorithm the predicate could be supplied directly and clearly
visible at the call site:
```
std::vector<double> data, result;
… // fill data
filter(data.begin(), data.end(), std::back_inserter(result),
       [](double e) { return (e < std::sqrt(2.0)); }
};
```

.N[
Note that the above will work with either version of `filter`, the one with the
[predicate parametrized to any type](#inside_algorithms) and the one with the
[predicate limited to an appropriate callable](#std_function_example_1).
]

---
template: plain
name: lambda_definition_syntax
header: ##### Lambda 101 – Argument Lists

The argument list and return value of a Lambda must always be compatible with
the expectations of the caller.

* Typically algorithms with a predicate argument hand over a container element
  as argument and expect a boolean return value.

* Most notable exceptions are algorithms expecting, establishing or maintaining 
  a sort order:
  * such hand over two container elements as argument and
  * expect `true` as return value if – for proper sort order – the first
    argument is to be placed before the second.

```
std::vector<double> data;
…
// sort doubles ascending (= default)
std::sort(data.begin(), data.end());
…
// sort doubles descending
std::sort(data.begin(), data.end(),
         [](double e1, double e2) { return (e2 < e1); });
```

---
template: plain
name: lambda_definition_syntax
header: ##### Lambda 101 – Named Lambdas

While for more complex tasks a named function or functor is preferable for
readability and maintainability, named lambdas are also worth a consideration
as their point of definition can be close to their use:
```
…
// sort doubles by their absolute values
auto fabs_cmp = [](double e1, double e2) {
                    return (std::fabs(e1) < std::fabs(e2));
                };
…
std::sort(data.begin(), data.end(), fabs_cmp);
```

.N.center[
This is not limited to lambdas used only one time.._[]
]

.F[:
If named lambdas are written for potential reuse it also makes sense to strive
for a more generic solution. C++14 allows using `auto` as argument type:
```
  // sort pairs by member `first` or `second`:
auto cmp_by_first = [](const auto& e1, const auto& e2) { return (e1.first < e2.first); };
auto cmp_by_second = [](const auto& e1, const auto& e2) { return (e1.second < e2.second); };
…
std::sort(data.begin(), data.end(), cmp_by_first);
std::stable_sort(data.begin(), data.end(), cmp_by_second);
```
]

---
template: plain
name: lambda_capture_list
header: ##### Lambda 101 – Capture Lists (Motivation)

To emphasize that important point once more: for any function (e.g. `filter`) 
expecting some other function as argument,

* the lambda handed over by the caller (e.g. *as argument to* `filter`)
* must be callable by the code inside (i.e. *the implementation of* `filter`).

Therefore it is not possible to hand over additional arguments directly:
```
void foo(std::vector<int> data, std::list<int> result, int max) {
    filter(data.begin(), data.end(), std::back_inserter(result),
           [](int e, int max) { return (e < max); });
};
```

.W[
This code will not compile._[] because the lambda doesn't match the expectation
`filter` has about its fourth argument.._[]
]

.F[:
How the error manifests in a compiler diagnostic is a different issue: for a
fully generic template the compiler will typically give a diagnostic for the
location where the actual call occurs and also point to the code by which that
particular instantiation was caused.
]

---
template: plain
name: lambda_capture_list_example
header: ##### Lambda 101 – Capture List Example

In a capture list variables from the local context are named.

Then in the code generated for the lambda that argument is transferred via a
special path:._[]
```
void foo(std::vector<int> data, std::list<int> result, int max) {
    filter(data.begin(), data.end(), std::back_inserter(result),
           [max](double e) { return (e < max); }
    );
}
```

.F[:
If you are curious about that path you will get an idea when
[Classic C++ Function Objects](#function_objects) are covered.
]

So far this presentation only tried to give some first clues about the purpose
and basic use of lambda capture lists.

.N[
There are many more details which have not been covered yet, like handing over
references in the capture list or some shortcuts for it.
]

Please lookup more information in the relevant reference documentation.

---
template: plain
name: lambda_capture_list_pitfalls
header: #### Beware of the Pitfalls with Lambdas

There are two broad categories of pitfalls:

* Not being aware of the fact that algorithms have the freedom to make a
  copy of a lambda, also copying its local data.

* Initializing a reference in a long-living lambda with a short(er)-living
  object instance or basic variable.

As in both cases the program will not come to the expected result,
inadvertently making a copy usually cause less harm.

.W[
Via dangling references unrelated memory locations may be accessed and even
modified, sometimes causing no effect until long after the fact.
]

---
template: plain
name: function_objects
header: #### Classic C++ Function Objects

Before C++11 introduced lambdas *Function Objects* or *Functors*._[] were the
way to go, if besides the arguments passed by the caller additional information
had to be passed to a piece of callable code.
```
class IsBelow {
    int max;
public:
    IsBelow(int m) : max(m) {}
    bool operator()(int m) const { return (e < max); }
};
…
void foo(std::vector<int> data, std::list<int> result, int max) {
    filter(data.begin(), data.end(), std::back_inserter(result),
           IsBelow(max));
}
```

---
template: plain
name: type_generic_functors
header: #### Type Generic Functors

Note that also Functors can be made type generic:
```
template <typename T>
class IsBelow {
    T max;
public:
    IsBelow(T m) : max(m) {}
    bool operator()(T m) const { return (e < max); }
};
```

This is rawly equivalent to `auto` arguments in lambdas, though there still
needs to be a type argument:._[]
```
void foo(std::vector<int> data, std::list<int> result, int max) {
    filter(data.begin(), data.end(), std::back_inserter(result),
           IsBelow<int>(max));
}
```

.F[:
This is expected to be alleviated in C++20.
Until the following helper function may come in handy:  
`template<typename T> IsBelow<T> gIsBelow(T v) { return IsBelow<T>(v); }`  
What turns the call of `filter` into:  
`filter(data.begin(), data.end(), std::back_inserter(result), gIsBelow(max));`
]

---
template: plain
name: local_context_ref_functors
header: #### Local Context by Reference (Functors)

Both, [Lambdas](#cpp11_lambdas) and [Functors](#function_objects) provide ways
to access variables from the local context by reference.

What needs to happen behind the scene is obvious in a functor:
```
template<typename T>
class PrintEnumerated {
    std::ostream& os;
    int& num;
public:
    PrintEnumerated(std::ostream& o, int& n) : os(o), num(n) {}
    void operator()(const T& e) { os << n++ << '\t' << e << '\n'; }
};
…
void foo(std::vector<int> data, std::ostream output) {
int lnum = 1;
std::foreach(data.cbegin(), data.cend(),
             PrintEnumerated<int>(output, lnum));
}
```

… but much of the code (adding the necessary members and a constructor
forwarding its arguments) is just boiler-plate.

---
template: plain
name: local_context_ref_lambdas
header: #### Local Context by Reference (Lambdas)

A lambda makes the code more succinct and to the point:._[]
```
void foo(std::vector<int> data, std::ostream &output) {
    int lnum = 1:
    std::foreach(data.cbegin(), data.cend(),
                [&output, &lnum](int e) {
                    output << ++lnum << '\t' << e << '\n';
                });
}
```

.F[:
The code could be made even more compact by abbreviating the capture list to a
single `&`:  
`[&](int e) { output << lnum++ << ":\t" << e; }`
]

---
template: plain
name: generalized_callables
header: ## Generalized Callables

Summarizing there as three forms of callable code:

* Classic C function pointers

* C++ Callable Objects._[] aka. Functors

* Lambdas introduced in C++11

All three are different types and hence can only vary if specified directly
or indirectly through a template argument.

.N.center[
The template `std::function` provides a common wrapper.
]

Argument and result types need to be to be fixed, though –
* callables need not match exactly,
* only within the limits of the standard conversions,  
  (as are supplied for any direct function call too).

.F[:
An object is *callable* if after any of its instances a pair of parentheses
enclosing an (optionally empty) argument is acceptable. This is achieved by
overloading `operator()`. **Note that in its definition the formal argument
list is supplied inside an extra set of parenthesis.**
]

---
template: plain
name: use_of_callables
header: ### Use of Callables

There are two main applications:

* Replacing a fully general template argument for an internal variation of some
  algorithm via an argument.

  * Usually this trades in a loss of runtime performance for a smaller memory
    footprint.
  * It also allows the compiler to give better error messages when the call
    is malformed.
<!-- -->

* When a variable (or a container) needs to refer to the actual code.

  * This could be call-backs in asynchronous (message based) designs, or
  * some loose coupling of encapsulated software components._[]

.F[:
In the world of design patterns this is also known as *Publisher-Subscriber*.
]

---
template: plain
name: std_function_example_1
header: ##### First Code Example with `std::function` 

This example shows how a predicate specified as fully generic type (though of
course bounded by its use) …
```
template<typename T, P>
std::size_t count_value_if(const std::vector<T> data, P pred) {
    std::size_t result = 0;
    for (auto e : data)
        if (pred(e)) ++result;
    return result;
}
```

… can be replaced with an `std::function`-type argument:
```
template<typename T>
std::size_t count_value_if(const std::vector<T> data,
                           std::function<bool(int)> pred) {
    // … same as before
}
```

The difference shows in the generated code but becomes even more obvious in the
error messages in case the actual callable has an incompatible signature.
         
---
template: plain
name: std_function_example_2
header: ##### Second Code Example with `std::function`

The following example demonstrates a bare-bones implementation of a
communication scheme in the spirit of the publisher-subscriber pattern:
```
struct slot_call : std::vector<std::function<void(const char*)> {
public:
    void operator()(const char *arg) const {
        for (const auto &fnc : *this) fnc(arg);
    }
};
```

The intended use is like this:
```
slot_call sc;                 // publisher object defined here
…  
                              // subscribers register handlers
sc.push_back([](const char* s) { /* ... like here ... */ });
sc.push_back([](const char* s) { /* ... and there ... */ });
…
while (auto cp = get_events()) // then publisher listens to ...
    sc(cp);                    // ... and distributes events
```

---
template: plain
name: use_of_callables
header: #### `std::function` Performance Considerations

When `std::function` is involved all **actual calls** will typically take place
via pointer indirection.

.center[
.N[
A call via `std::function` is comparable to a `virtual` member function.
]

If alternative implementations are possible, the rule of thumb is this:
]

.pull-left[

* An `std::function`-type, i.e. a callable *bound in its definition* to a fixed
signature, tends to

  * generate **less**
  * but **slower** code.
]

.pull-right[

* A generic templated type, only bounded *by its use as callable*, tends to

  * generate **more**
  * but **faster** code.
]

---
template: plain
name: std_bind_vs_lambdas
header: ### `std::bind` vs. Lambdas

Lambdas are also useful to adapt more generic functions to a specific use.

This may be any or a combination of

* binding one or more arguments to fixed values
* binding arguments in a different order.

The following examples assumes a

* `drawing` composed of
* `point`s and taking a
* `pen` to create a visual representation:

```
struct point { int x, y; };
struct drawing : private std::vector<point> {
    using pen_t = std::function<void(double x, double y)>;
    void draw(pen_t pen) {
        for (const auto pt : *this) pen(pt.x, pt.y);
    }
};
```

---
template: plain
name: std_bind_example
header: ##### Code Example with `std::bind`

Further assuming there is the following function
```
void my_test_pen(std::ostream& os, int yc, int xc) {
    os << "x= " xc << ", y=" << yc << '\n';
}
```
which is not exactly but close to the expected `pen`.

```
drawing d = {{0,1}, {3,7}, {4,6}, {1,1}, {0,1}};
…
using namespace std::placeholders;
d.draw(std::bind(my_test_pen, std::ref(std::cout), _2, _1));
```

Alternatively a lambda may be used:._[]
```
d.draw([](int x, int y) { my_test_pen(std::cout, y, x); });
```

.F[:
Note that `std::cout` is a global object instance and therefore directly
available in a lambda body. If the stream to use would come from a local
variable or function parameter `std::ostream os` and the lambda arguments were
renamed to `_1` and `_2`, the comparison would come even closer:  
`d.draw(std::bind(my_test_pen, std::ref(os), _2, _1));` vs.  
`d.draw([&os](int _1, int _2) { my_test_pen(os, _2, _1); });`
]

---
template: plain
name: more_pitfalls_with_callables
header: #### More Pitfalls with Callables

A general pitfall when using callables returned from `std::bind` or created
with lambdas is that C++ has no garbage collection.

.W[
Especially if the callables are handed over back and forth, the code must be
carefully designed and should be reviewed with life-time issues in mind!
]

This was (obviously?) not the case for the following two fragments.._[]

.pull-left[
Houston, we have a problem …

```
void g(std::ostream&, int);
…
std::function<void(int)> f() {
    using namespace std;
    using placeholders::_1;
    ostringstream os;
    return bind(g, ref(os), _1);
}
```
]

.pull-right[
… similar over here:
```
void g(std::ostream&, int);
…
std::function<void(int)> f() {
    std::ostringstream os;
    return [&os](int x) {
                g(os, x);
           };
}
```
]

.F[:
So that the problem manifests itself there must of course be a call like this:
`f()(42);`
]

---
template: plain
name: appendices
header: ## Appendices and Info-Graphics

##### General Hardware Model and Mapping of C++

* [Hardware Execution Model			](#execution_model)
* [Class to Memory Mapping			](#class_to_memory)
* [Exception Basic Principles			](#exception_basics)
* [Smart Pointers				](#smart_pointers)

##### Templates

* [Template Classes and Functions		](#template_basics)
* [Parametrizing Types and Sizes		](#param_types_sizes)

##### Standard Library

* [Standard Strings 				](#std_string_basics)
* [I/O-Stream Basics				](#io_stream_basics)
* [STL Design Overview				](#stl_design_overview)
* [STL Sequence Containers			](#stl_sequence_cont)
* [STL Associative Containers			](#stl_associative_cont)
* [C++11 Regular Expression API			](#cpp11_regex_api)

---
template: linkinfo
graphic: ExecutionModel
name: execution_model
header: #### Execution Model

Basic hardware components and their typical use in C/C++ programs.

---
template: linkinfo
graphic: ClassToMemoryMapping
name: class_to_memory
header: #### Class to Memory Mapping

How C++ classes are mapped to memory (and finally decay to C data `struct`-s),
including Composition and Inheritance.

---
template: linkinfo
graphic: RuntimeTypeIdentification
name: virtual_mfn_call
header: #### Run-Time Type Identification

Comparing specific run-time type identification via virtual member function
with its explicit form.

---
template: linkinfo
graphic: ExceptionBasics
name: exception_basics
header: #### Exception Basic Principles

View of exceptions as non-local branches, typically used for error recovery
paths.

---
template: linkinfo
graphic: SmartPointers
name: smart_pointers
header: #### C++11 Smart Pointers

Principles and Implementation of Smart Pointers (as provided by C++11).

---
template: linkinfo
graphic: TemplateBasics
name: template_basics
header: #### Template Classes and Functions

Basic use of C++ Templates for classes and functions.

---
template: linkinfo
graphic: ParametrizedTypesAndSizes
name: param_types_sizes
header: #### Parametrizing Types and Sizes

Example for parametrizing (element) types and size of a generic `RingBuffer`
class.

---
template: linkinfo
graphic: StringBasics
name: std_string_basics
header: #### Basics String Handling

Overview of architecture and some details of the `std::string` class.

---
template: linkinfo
graphic: IOStreamBasics
name: io_stream_basics
header: #### I/O-Stream Basics

Overview of architecture and some details of I/O-streams.

---
template: linkinfo
graphic: STL-IteratorUsages
name: stl_design_overview
header: #### STL Architecture Overview

Overview of the STL Architecture, emphasizing the use of iterators as kind of
"glue" between containers and algorithms

---
template: linkinfo
graphic: STL-SequenceContainers
name: stl_sequence_cont
header: #### STL Sequence Containers

Depicting implementation of STL Sequence Containers.

But also note: The STL specification asserts performance and other properties,
**not** a specific implementation!

---

template: linkinfo
graphic: STL-AssociativeContainers
name: stl_associative_cont
header: #### STL Associative Containers

Depicting implementation of STL Associative Containers.

But also note: The STL specification asserts performance and other properties,
**not** a specific implementation!

---
template: linkinfo
graphic: RegularExpressions
name: cpp11_regex_api
header: #### C++11 Regular Expression API

Understanding the Regular Expressions API in C++11.

---
template: plain
name: appendices
header: ## Appendices and Info-Graphics

This sections collects:

* [Info-Graphics Used Regularly			](#regular_infographics)

* [Optional Info-Graphics			](#opt_infographics)

The former are linked from other pages of this presentation, the latter may be
used to answer specific questions sometimes posed by participants.

---
template: plain
name: regular_infographics
header: #### Regular Info-Graphics

##### General Hardware Model and Mapping of C++

* [Hardware Execution Model			](#execution_model)
* [Class to Memory Mapping			](#class_to_memory)
* [Exception Basic Principles			](#exception_basics)
* [Smart Pointers				](#smart_pointers)

##### Templates

* [Template Classes and Functions		](#template_basics)
* [Parametrizing Types and Sizes		](#param_types_sizes)

##### Standard Library

* [Standard Strings 				](#std_string_basics)
* [I/O-Stream Basics				](#io_stream_basics)
* [STL Design Overview				](#stl_design_overview)
* [STL Sequence Containers			](#stl_sequence_cont)
* [STL Associative Containers			](#stl_associative_cont)
* [C++11 Regular Expression API			](#cpp11_regex_api)

---
template: linkinfo
graphic: ExecutionModel
name: execution_model
header: #### Execution Model

Basic hardware components and their typical use in C/C++ programs.

---
template: linkinfo
graphic: ClassToMemoryMapping
name: class_to_memory
header: #### Class to Memory Mapping

How C++ classes are mapped to memory (and finally decay to C data `struct`-s),
including Composition and Inheritance.

---
template: linkinfo
graphic: RuntimeTypeIdentification
name: virtual_mfn_call
header: #### Run-Time Type Identification

Comparing specific run-time type identification via virtual member function
with its explicit form.

---
template: linkinfo
graphic: ExceptionBasics
name: exception_basics
header: #### Exception Basic Principles

View of exceptions as non-local branches, typically used for error recovery
paths.

---
template: linkinfo
graphic: SmartPointers
name: smart_pointers
header: #### C++11 Smart Pointers

Principles and Implementation of Smart Pointers (as provided by C++11).

---
template: linkinfo
graphic: TemplateBasics
name: template_basics
header: #### Template Classes and Functions

Basic use of C++ Templates for classes and functions.

---
template: linkinfo
graphic: ParametrizedTypesAndSizes
name: param_types_sizes
header: #### Parametrizing Types and Sizes

Example for parametrizing (element) types and size of a generic `RingBuffer`
class.

---
template: linkinfo
graphic: StringBasics
name: std_string_basics
header: #### Basics String Handling

Overview of architecture and some details of the `std::string` class.

---
template: linkinfo
graphic: IOStreamBasics
name: io_stream_basics
header: #### I/O-Stream Basics

Overview of architecture and some details of I/O-streams.

---
template: linkinfo
graphic: STL-IteratorUsages
name: stl_design_overview
header: #### STL Architecture Overview

Overview of the STL Architecture, emphasizing the use of iterators as kind of
"glue" between containers and algorithms

---
template: linkinfo
graphic: STL-SequenceContainers
name: stl_sequence_cont
header: #### STL Sequence Containers

Depicting implementation of STL Sequence Containers.

But also note: The STL specification asserts performance and other properties,
**not** a specific implementation!

---

template: linkinfo
graphic: STL-AssociativeContainers
name: stl_associative_cont
header: #### STL Associative Containers

Depicting implementation of STL Associative Containers.

But also note: The STL specification asserts performance and other properties,
**not** a specific implementation!

---
template: linkinfo
graphic: RegularExpressions
name: cpp11_regex_api
header: #### C++11 Regular Expression API

Understanding the Regular Expressions API in C++11.

---
template: plain
name: opt_infographics
header: #### Optional Info-Graphics (Mixed 1)

##### General Goals of Software Design

* [Guiding Principles					](#design_principles)

##### Unified Modelling Language

* [Classes and Relations in UML				](#quick_uml)
* [Classes Relations by Example				](#class_design)

##### Various Applications of `virtual` Member Functions

* [Type Based Branching (Practical RTTI)		](#practical_rtti)
* [Two Implementations of the "Open/Close" (Principle)	](#two_open_closed)

---
template: plain
name: opt_infographics_2
header: #### Optional Info-Graphics (Mixed 2)

##### More on Inheritance

* [Multiple Inheritance (Principle)			](#multi_inherit)
* [Problems of Diamond-Shaped Inheritance		](#multi_diamond)

##### More on Iterators

* [C++98 Iterator Categories				](#iter_categories)
* [Specific Iterator Details				](#iter_specifics)

##### More on Resource Management and Exceptions

* [RAII Style Resource Management			](#raii_style_resources)
* [Specific Exception Details				](#exception_specifics)

##### More on C++ Templates

* [Reducing Code Bloat by Templates			](#template_bloat)

---
template: linkinfo
graphic: GuidingPrinciples
name: design_principles
header: #### Guiding Principles

Partitioning to tackle complexity and provide chances to come up with to
components that can be used in flexible ways is at the core of all software
design (if not at the core of all engineering).

---
template: linkinfo
graphic: UML-ClassesAndRelations
name: quick_uml
header: #### Classes and Relations (Quick UML)

UML Notation to graphically depict classes and their typical relations.

---
template: linkinfo
graphic: Example-ClassDesign
name: class_design
header: #### Class Relations by Example

Some examples for class relations, highlighting options for reuse and flexible
extensibility.

---
template: linkinfo
graphic: TypeBasedBranching
name: practical_rtti
header: #### Type Based Branching

Comparing explicit use of RTTI to (usually more elegant) type-based branching
via virtual member functions.

---
template: linkinfo
graphic: Example-OpenClosePrinciple
name: two_open_closed
header: #### Two Implementations of "Open/Close"

Comparing the "open/close" approach based on virtual member functions and
templates.

---
template: linkinfo
graphic: MultipleInheritance
name: multi_inherit
header: #### Mutiple Inheritance (Principle)

Showing the principles of multiple inheritance (also preparing diamond-shaped
inheritance).

---
template: linkinfo
graphic: DiamondShapedInheritance
name: multi_diamond
header: #### Diamond-Shaped Inheritance

Showing special handling and considerations if multiple inheritance turns into
a diamond-shaped relation.

---
template: linkinfo
graphic: STL-IteratorCategories
name: iter_categories
header: #### C++98 Iterator Categories

Main Iterator Categories as defined by C++98.

---
template: linkinfo
graphic: STL-IteratorDetails
name: iter_specifics
header: #### IteratorSpecific Details

Some more iterator specific details (like `const_`-iterators versus mutable …).

---
template: linkinfo
graphic: ResourceManagement
name: raii_style_resources
header: #### RAII Style Resource Management

Managing Resources via RAII (Resource Acquisition is Initialisation).

---
template: linkinfo
graphic: ExceptionDetails
name: exception_specifics
header: #### Specific Exception Details

Some more specific details on exceptions (like *do*-s and *don't*-s).

---
template: linkinfo
graphic: ReducingCodeBloat
name: template_bloat
header: #### Reducing Code Bloat by Templates

Understanding the nature of C++ templates and how to reduce code bloat.



</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
